% arara: pdflatex
% arara: pdflatex
% arara: pdflatex

% options:
% thesis=B bachelor's thesis
% thesis=M master's thesis
% czech thesis in Czech language
% slovak thesis in Slovak language
% english thesis in English language
% hidelinks remove colour boxes around hyperlinks

\documentclass[thesis=B,czech]{FITthesis}[2019/12/23]

\usepackage[utf8]{inputenc} % LaTeX source encoded as UTF-8

\usepackage{amsmath} %advanced maths
\usepackage{amssymb} %additional math symbols
\usepackage{xevlna}
\usepackage{amsthm}
\usepackage{dirtree} %directory tree visualisation
\usepackage[linesnumbered,ruled]{algorithm2e}
\usepackage{pgf-umlcd}
\usepackage{tikz}
\usetikzlibrary{automata, positioning, arrows}

\tikzset{->,  % makes the edges directed
>=stealth', % makes the arrow heads bold
node distance=6cm, % specifies the minimum distance between two nodes. Change if necessary
every state/.style={thick, fill=gray!10}, % sets the properties for each ’state’ node
initial text=$start$, % sets the text that appears on the start arrow}
}
\usepackage{todonotes}
\usepackage{listings}
\usepackage[symbol]{footmisc}
% % list of acronyms
% \usepackage[acronym,nonumberlist,toc,numberedsection=autolabel]{glossaries}
% \iflanguage{czech}{\renewcommand*{\acronymname}{Seznam pou{\v z}it{\' y}ch zkratek}}{}
% \makeglossaries

\theoremstyle{definition} 
\newtheorem{definition}{Definice}[chapter]
\newtheorem{example}{Příklad}[chapter]
\newtheorem{theorem}{Věta}[chapter]
\newtheorem{lemma}{Lemma}[chapter]
\newtheorem{problem}{Problém}[chapter]
\newtheorem{pozorovani}{Pozorování}[chapter]

\newcommand{\tg}{\mathop{\mathrm{tg}}} %cesky tangens
\newcommand{\cotg}{\mathop{\mathrm{cotg}}} %cesky cotangens

\renewcommand{\thefootnote}{\fnsymbol{footnote}}
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% ODTUD DAL VSE ZMENTE
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\department{Katedra teoretické informatiky}
\title{Zpracování POSIX regulárních výrazů}
\authorGN{Oleksandr} %(křestní) jméno (jména) autora
\authorFN{Zaporozhchenko} %příjmení autora
\authorWithDegrees{Oleksandr Zaporozhchenko} %jméno autora včetně současných akademických titulů
\author{Oleksandr Zaporozhchenko} %jméno autora bez akademických titulů
\supervisor{Ing. Ondřej Guth, Ph.D.}
\acknowledgements{Rád bych zde poděkoval Ing. Ondřeji Guthovi, Ph.D. za vedení mé bakalářské práce, cenné rady a čas, který mi věnoval při zpracování daného tématu. Dále děkuji svým rodičům a bratrovi, kteří mě podporovali a pomáhali při studiu.
}
\abstractCS{Rozšířením tradiční syntaxe regulárních výrazů o zpětné reference vznikne mocný prostředek, kterým lze popsat jazyky silnější než regulární. Tato bakalářská práce se zabývá problémem zpracování regulárních výrazů se zpětnými referencemi. v~práci je implementován v~jazyce C++ algoritmus založený na konstrukci vícepáskového Turingova stroje a algoritmus od Schmida, který řeší verzi tohoto problému parametrizovanou stupněm aktivních proměnných (\emph{active variable degree}). v~závěru je program testován a porovnán s~již existujícími nástroji pro práci s~regulárními výrazy na vytvořených sadách testů. Mimo jiné je v~práci předložen alternativní důkaz věty o NP-úplnosti zkoumaného problému.}
\abstractEN{This bachelor's thesis deals with the matching problem of regular expressions with backreferences (regex, for short), which is a feature available in most modern matching engines. It allows the user to specify even non-regular languages. The chosen algorithm based on the construction of a multi-tape Turing machine and Schmid's algorithm for this problem parametrized by the active variable degree were implemented in C++. All the implementations are tested on created test sets and compared with already existing applications. This paper gives, among other things, an alternative proof of the NP-completeness of the matching problem of regex.}
\placeForDeclarationOfAuthenticity{V~Praze}
\declarationOfAuthenticityOption{4} %volba Prohlášení (číslo 1-6)
\keywordsCS{regulární výraz, zpětná reference, Turingův stroj, referenční slovo, problém zpracování, důkaz NP-úplnosti, parametrizovaná složitost, aktivní proměnná, implementace, C++, vytvoření testovacích sad, grep, Perl}
\keywordsEN{regex, backreference, Turing machine, ref-word, regex matching problem, NP-complete proof, parametrized complexity, active variable, implementation, C++, test set creation, grep, Perl}
% \website{http://site.example/thesis} %volitelná URL práce, objeví se v~tiráži - úplně odstraňte, nemáte-li URL práce

\begin{document}

% \newacronym{CVUT}{{\v C}VUT}{{\v C}esk{\' e} vysok{\' e} u{\v c}en{\' i} technick{\' e} v~Praze}
% \newacronym{FIT}{FIT}{Fakulta informa{\v c}n{\' i}ch technologi{\' i}}

\begin{introduction}
V dnešní době je těžké najít textový editor, který by nepodporoval regulární výrazy. Mezi nejčastější využití tohoto formalismu pro popis formálních jazyků patří vyhledávání a nahrazování v~textu. V~praxi používaná syntaxe regulárních výrazu se značně liší od formálního algebraického zápisu. Jeden z~nejznámějších standardů IEEE POSIX \cite{posix} definuje konstrukce, které umožňují nejen zapsat výraz jednodušším způsobem, ale i popsat jazyky silnější než regulární. Tato práce je zaměřena na jeden z~takových prostředků syntaxe, který se nazývá \emph{zpětná reference} (anglicky \emph{backreference}).

Cílem teoretické části práce je popsat tzv. problém zpracování regulárních výrazů se zpětnými referencemi a formalizovat známé algoritmy pro řešení tohoto problému. Mezi cíle praktické části patří implementace vybraného algoritmu, vytvoření testovacích sad a porovnání výpočetních časů implementace s~existujícími nástroji pro práci s~regulárními výrazy. Jedním z~nedostatků většiny dostupných implementací je fakt, že některé regulární výrazy se zpětnými referencemi nejsou podporovány, resp. je není možné zapsat v~požadované notaci. Přínosem praktické části je také nový přístup k~dokazování NP-úplnosti daného problému založený na pojmu referenčního slova. Na nesprávnost existujícího důkazu \cite[s. 289]{alfred2014algorithms} poukazoval ve své práci Schmid \cite[s. 83]{schmidregex}.

Práce má následující strukturu. v~první kapitole jsou uvedeny různé způsoby definování regulárních výrazu se zpětnými referencemi (regexy a semiregexy) a jejich výpočetní síla. Hodnota regexu je v~práci definována pomocí tzv. \emph{referenčních slov} (anglicky \emph{ref-words}) \cite{schmidrefwords}. V~kapitole je také prozkoumán vztah regexů a referenčního slova, které daný regex generuje. Druhá kapitola se zabývá problémem zpracování regexů, výpočetními modely, které rozpoznávají \textsc{Regex} jazyky, a algoritmy pro převod regexu na vícepáskový Turingův stroj a memory automat. Součásti této kapitoly je také návrh bezkontextové gramatiky generující \textsc{Regex} jazyky a abstraktního syntaktického stromu reprezentujícího libovolný regex. Třetí kapitola je věnována problému zpracování z~hlediska teorie parametrizované složitosti. Pro regex je v~této kapitole zaveden parametr složitosti \emph{avd} (anglicky \emph{active variable degree} \cite{schmidref}) a je také popsána efektivní metoda konstrukce memory automatu, v~němž počet paměťových prvků záleží pouze na parametru \emph{avd} vstupního regexu. Dále jsou implementovány dva algoritmy založené na konstrukci memory automatu a jeden na konstrukci TS. V~poslední kapitole jsou tyto algoritmy otestovány na vytvořených datových sadách. Na konci práce jsou změřeny a porovnány výpočetní časy implementací autora s~nástrojem \emph{grep} a regulárními výrazy v~jazyce \emph{Perl}. 

\end{introduction}

\chapter{Regulární výrazy se zpětnými referencemi}

V práci jsou používány základní pojmy teorie formálních jazyků a automatů, jejichž znalost se u čtenáře předpokládá. Standardní definice z~teorie deterministické syntaktické analýzy jsou také vzhledem k~povaze textu vynechány. V~případě nejasností autor práce odkazuje čtenáře na publikace \cite{hopcroft}, \cite{sestakova} a \cite{aho_lam_sethi_ullman_2007}.
\section{Standardy regulárních výrazů}
Regulární výrazy jsou v~současné době používány ve většině programovacích jazyků a textových editorů. Mezi nejpoužívanější standardy definující regulární výrazy patří IEEE POSIX a PCRE (Perl Compatible Regular Expressions). v~těchto standardech jsou definovány mimo jiné zpětné odkazy a další konstrukce, kterými lze popsat jazyky silnější než regulární. v~základních regulárních výrazech POSIX (BRE) se objevuje výraz tvaru $\backslash i$. Tato konstrukce označuje zpětnou referenci na podvýraz, který se nachází v~$i$-té závorce zleva (závorky se číslují podle pozice otevírací závorky). Zatímco počet číslovaných skupin zachycení v~regulárním výrazu podle standardu POSIX BRE je omezen devíti \cite[s. 233]{posix}, ve výrazech podle PCRE může existovat až 100 číslovaných skupin zachycení (i~když se třeba způsob zápisu liší). Standard PCRE zavádí také pojmenované zpětné odkazy \cite{pcre}, které mají stejný sémantický význam jako číslované odkazy.
\section{Syntaxe regulárních výrazů se zpětnými referencemi}

Regulární výrazy se zpětnými referencemi je možné definovat několika způsoby. Jeden rozdíl spočívá v~tom, jak je označen podřetězec, na nějž se ve výrazu odkazuje. Další způsob definování, v~němž je podřetězec vázán na závorku, je popsán v~\cite{campeanu}. Jelikož závorky jsou očíslovány vzestupně zleva doprava, není možné v~těchto výrazech zopakovat \uv{definici} závorky.

\begin{definition}[Freydenberger--Schmid]
Buď $X$ konečná množina proměnných, buď $\Sigma$ abeceda ($X\cap\Sigma = \varnothing$). Potom \emph{regulární výraz se zpětnými referencemi} (nad $\Sigma$ a $X$), dále zkracováno na \emph{regex}, je každý řetězec získaný aplikací následujících pravidel v~konečně mnoha krocích. 
Množina všech řetězců definovaných tímto způsobem je značena $RV_{\Sigma, X}$. Množina proměnných, které se vyskytují ve výrazu $\alpha$, se značí $var(\alpha)$.
\begin{enumerate}
	\item{$a \in RV_{\Sigma, X}$ a $var(a) = \varnothing$ pro všechna $a \in \Sigma\cup\{\varnothing, \varepsilon\}$.}
	\item{Jestliže $\alpha$, $\beta \in RV_{\Sigma, X}$, pak také  $(\alpha) \in RV_{\Sigma, X}$, $\alpha^\ast \in RV_{\Sigma, X}$ ($var(\alpha^\ast)=var(\alpha)$),  $\alpha + \beta \in RV_{\Sigma, X}$ a $\alpha \cdot \beta \in RV_{\Sigma, X}$ ($var(\alpha + \beta)=var(\alpha \cdot \beta)=var(\alpha)\cup var(\beta)$).}
	\item(\emph{definice proměnné}){ $x \{ \alpha \} \in RV_{\Sigma, X}$ a $var(x \{\alpha\}) = var(\alpha)\cup\{x\}$ pro $x \in X \setminus var(\alpha)$ a $\alpha \in RV_{\Sigma, X}$.}
	\item(\emph{zpětná reference}){ $x \in RV_{\Sigma, X}$ a $var(x) = \{x\}$ pro všechna $x \in X$. \cite{schmidref}}
\end{enumerate}
\end{definition}

\begin{example} 
Buď $X=\{x\}$ množina proměnných, buď $\Sigma=\{a, b\}$ abeceda. Výraz $(x x\{a\})^\ast$ je validním regexem z~množiny $RV_{\Sigma, X}$. Naopak ani řetězec $x\{x\{a^\ast\}\}$, ani $x\{xa\} \ x$ nepatří do $RV_{\Sigma, X}$, protože oba výrazy lze zapsat jako $x\{\varphi\}$ a $var(\varphi) = \{x\}$, což neodpovídá bodu 3 definice regexu.
\end{example}

\begin{definition}[Câmpeanu--Salomaa--Yu semiregex]
Buď $\Sigma$ abeceda. Potom \emph{semiregulární výraz se zpětnými referencemi} (nad $\Sigma$), dále zkracováno na \emph{semiregex}, je každý řetězec získaný aplikací následujících pravidel v~konečně mnoha krocích. Množina všech řetězců definovaných tímto způsobem je značena $RV_{\Sigma}^{CSY}$.
\begin{itemize}
	\item{$\varnothing$, $\varepsilon$, $a \in RV_{\Sigma}^{CSY}$ pro všechna $a \in \Sigma$.}
	\item{Jestliže $\alpha$, $\beta \in RV_{\Sigma}^{CSY}$, pak také $(\alpha) \in RV_{\Sigma}^{CSY}$, $\left(\alpha + \beta \right) \in RV_{\Sigma}^{CSY}$, $\left(\alpha \cdot \beta \right)\in RV_{\Sigma}^{CSY}$ a $(\alpha)^\ast \in RV_{\Sigma}^{CSY}$.}
	\item(\emph{zpětná reference}){ $\backslash n \in RV_{\Sigma}^{CSY}$, kde $n \in \mathbb{N} $ a hodnota $\backslash n$ odpovídá hodnotě dílčího výrazu v~$n$-té závorce. \cite{campeanu}} 
\end{itemize}
\end{definition}

\begin{example} 
Řetězec $(_1(_2 a^\ast )_2 + \varepsilon)_1 \backslash 1 (_1 (_3 b^\ast )_3 + \varepsilon )_1 \backslash 1 $ není validním semiregexem, protože třetí otevírací závorka zleva může být označena pouze číslem~3.  Naopak množina $RV_{\Sigma, X}$ obsahuje například řetězec $\alpha = (x \{ a^\ast \} +  \varepsilon)\  x \ (x\{b^\ast \} +  \varepsilon) \ x$. Regex $\alpha$ popisuje formální jazyk $L = \{a^{3n} \mid n \in \mathbb{N}_0 \} \cup \{\varepsilon\} \cup {\{a^{2n} b^{2k} \mid n, k~\in \mathbb{N}_0 \}} \cup \{b^{2n} \mid n \in \mathbb{N}_0 \}$. Řetězcem z~$RV_{\Sigma}^{CSY}$, který reprezentuje jazyk $L$, je například $((_2 a^\ast )_2 \backslash 2 (_3 b^\ast )_3  \backslash 3) + \varepsilon + ((_5 a^\ast )_5 \backslash 5 \backslash 5) + ((_7 b^\ast )_7 \backslash 7) $.
\end{example}

Ve většině případů regexy umožňují popsat nějaký formální jazyk jednodušším způsobem. Jelikož existuje formální jazyk $L$, který lze popsat regexem z~$RV_{\Sigma, X}$, ale žádný semiregex z~$RV_{\Sigma}^{CSY}$ nereprezentuje $L$, a každý semiregex lze triviálně převést na ekvivalentní regex \cite[s. 38--40]{berglund}, lze považovat regex za silnější formalismus (toto je hlavní důvod, proč se v~této práci používají regexy).

Podobně jako pro klasické regulární výrazy \cite{eggan} lze pro regexy definovat hvězdnou výšku (anglicky \emph{star-height}). Hodnota výšky určuje maximální počet do sebe vnořených iterací ve výrazu. 

\begin{definition}
Buď $\Sigma$ abeceda, buď $X$ množina proměnných. Hvězdná výška $\lambda(\varphi)$ pro libovolný regex $\varphi$ z~$RV_{\Sigma, X}$ je definována takto:
\begin{itemize}
	\item{$\lambda(a) = 0$ pro $a \in \Sigma\cup\{\varepsilon, \varnothing\}$,}
	\item{$\lambda(x) = 0$ pro $x \in X$,}
	\item{Pro $\alpha$, $\beta \in RV_{\Sigma, X}$ $\lambda(\alpha\beta) = \lambda(\alpha+\beta) = max\{\lambda(\alpha), \lambda(\beta)\}$ a  $\lambda(\alpha^\ast) = \lambda(\alpha)+1$,}
	\item{Pro $\alpha \in RV_{\Sigma, X}$, $x \in X\setminus var(\alpha)$ $\lambda(x\{\alpha\}) = \lambda(\alpha)$.}
\end{itemize}
\end{definition}

\begin{example}
	$\lambda( \ (x \ x\{a^\ast\})^\ast) = \lambda(x \ x\{a^\ast\})+1=max\{\lambda(x), \lambda(x\{a^\ast\})\}+1=max\{0, \lambda(a^\ast)\}+1=max\{0, \lambda(a)+1\}+1=max\{0, 1\}+1 = 2$.
\end{example}

\section {Hodnota regexu a REGEX jazyky}
V této sekci je zkoumána vyjadřovací síla regexů a definována třída \textsc{Regex} jazyků. Nejprve se zavede pojem \emph{hodnoty regexu}. Podobně jako u regulárních výrazů, hodnota je definována jako formální jazyk, který daný výraz popisuje. Při definování bude vycházeno z~\cite{schmidrefwords} a\cite{fsdeter}.

\begin{definition}
Buď $\Sigma$ abeceda, buď $X$ konečná množina proměnných a buď $\Gamma = \{ [\,_x , ]\,_x \mid x \in X \}$. Konečná posloupnost znaků z~$\Sigma \cup X \cup \Gamma$ se nazývá \emph{referenční slovo}. Referenční jazyk je konečná množina referenčních slov. \cite{schmidrefwords}
\end{definition}

Je možné podívat se na regexy jako na generátory referenčních slov, což znamená, že pro každý regex lze definovat referenční jazyk.

\begin{definition}\label{def:reflan}
Buď $\Sigma$ abeceda, buď $X$ konečná množina proměnných a buď $\Gamma = \{ [\,_x , ]\,_x \mid x \in X \}$. Lze definovat \emph{referenční jazyk} pro libovolný regex $\alpha$ následovně:
\begin{enumerate}
	\item{$R\left(\varnothing\right) = \varnothing$,}
	\item{$R\left(a\right) = \{a\} $ pro $ a \in \Sigma \cup \{ \varepsilon \}$,}
        \item{$R\left(x\right) = \{x\} $ pro $ x \in X$,}
        \item\label{rule:4}{$R\left(x\{ \alpha \}\right) = \{ [\,_x \} \cdot R\left( \alpha \right)  \cdot \{]\,_x \}$ pro $x \in X$ a $\alpha \in RV_{\Sigma, X}$,}
        \item{$R\left(\alpha\cdot\beta\right) = R\left(\alpha\right)\cdot R\left(\beta\right)$, kde $\alpha, \beta \in RV_{\Sigma, X}$,}
        \item{$R\left(\alpha + \beta\right) = R\left(\alpha\right)\cup R\left(\beta\right)$, kde $\alpha, \beta \in RV_{\Sigma, X}$,}
        \item{$R\left(\alpha^\ast\right) = R\left(\alpha\right)^\ast$, kde $\alpha \in RV_{\Sigma, X}$. \cite{fsdeter}}
\end{enumerate}
\end{definition}

\begin{pozorovani}\label{poz:hodnota}
Nechť $\Sigma^\prime = \Sigma \cup X \cup \Gamma$. Provede-li se substituce všech definic $x \{ \beta \}$ v~nějakém regexu $\alpha \in RV_{\Sigma, X}$ na výrazy $[\,_x \beta ]\,_x$, hodnota výsledného výrazu $\alpha^\prime$ se rovná referenčnímu jazyku $R(\alpha)$ ($\alpha^\prime$ je regulárním výrazem nad~$\Sigma^\prime$ dle definice). \cite[s. 4]{fsdeter}
\end{pozorovani}

\begin{example} 
Regex $\alpha = \left( b^\ast c \right)^\ast x \{ a^\ast c \} \ x $ generuje například referenční slovo $\left(b^9a\right)^3 [\,_x a^2 c ]\,_x \ x$.

Referenční slovo $r = [\,_x aa  [\,_y c ]\,_x aaa ]\,_y$ nelze generovat žádným regexem. Pokud by nějaký regex $\beta$ generoval $r$, potom podřetězec  $[\,_x aa  [\,_y c ]\,_x$ byl vygenerován pomocí pravidla \ref{rule:4} z~definice \ref{def:reflan}. To znamená, že podřetězec $aa  [\,_y c$  byl vygenerován z~nějakého regexu $\alpha_0$, což není možné. Jediné pravidlo, pomocí něhož lze získat znak $[\,_y$, je pravidlo \ref{rule:4}. Pak ale $aa  [\,_y c$ obsahuje také znak $]\,_y$, což není pravda.
\end{example}

Z předchozího příkladu vyplývá, že ne každé referenční slovo lze vygenerovat pomocí regexu. Pod pojmem \uv{referenční slovo} je dále myšlen pouze řetězec z~podmnožiny validních slov, který je definován následovně.

\begin{definition}
Buď $\Sigma$ abeceda, buď $X$ konečná množina proměnných a buď $\Gamma = \{ [\,_x , ]\,_x \mid x \in X \}$. Referenční slovo $r$ nad $\Sigma \cup X \cup \Gamma$  je \emph{validní}, pokud existuje $\alpha \in RV_{\Sigma, X}$ tak, že platí $r \in R\left(\alpha\right)$.
\end{definition}

\uv{Výskyt proměnné $x \in X$ v~referenčním slově funguje jako ukazatel na nejbližší podřetězec tvaru $[\,_x \alpha  ]\,_x$, který se nachází vlevo}. \cite{fsdeter} v~další definici je ukázáno, jak lze formálně převést referenční slovo nad $\Sigma \cup X \cup \Gamma$ na slovo nad $\Sigma$ (v původním textu se této operaci říká \emph{dereference}). Zjednodušeně lze níže uvedené kroky popsat následovně:
   
\emph{Každá proměnná $x$ se substituuje za příslušný podřetězec, na nějž daná proměnná odkazuje (nebo za $\varepsilon$, pokud se nalevo nevyskytuje podřetězec $[\,_x \dots \ ]\,_x$), a všechny znaky z~$\Gamma = \{ [\,_x , ]\,_x \mid x \in X \}$ z~řetězce budou odstraněny.}
\begin{definition}
Buď $r$ referenční slovo nad ${\Sigma \cup X \cup \Gamma}$, buď $var \left( x \right)$ počet znaku $x$ v~$r$ a buď $X^\prime = \bigcup\limits_{x \in X} \bigcup\limits_{i=1}^{i \leq var \left( x \right)} \{x_i\}$. Výraz $r^\prime$ je $r$, v~němž jsou proměnné očíslované ($r^\prime \in \left(\Sigma \cup X^\prime  \cup \Gamma \right)^\ast$). Pro $r^\prime$ jsou definovány homomorfismy $deref_0^{r^\prime} :  \left(\Sigma \cup X^\prime \cup \Gamma\right)^\ast \rightarrow  \left(\Sigma \cup \Gamma\right)^\ast$ a $deref_1^{r^\prime} : \left(\Sigma \cup \Gamma\right)^\ast \rightarrow \Sigma^\ast$ následovně:
\begin{enumerate}
	\item{$deref_0^{r^\prime} \left( a \right) = a$ pro $a \in \Sigma \cup \Gamma$, }
	\item{$deref_0^{r^\prime} \left( x_i \right) = deref_1^{r^\prime} \left( deref_0^{r^\prime} \left( \alpha \right) \right) $, pokud platí $x_i \in X^\prime \ \wedge $ \\ \bigg($\exists  \alpha, a, b, c \in \left(\Sigma \cup X \cup \Gamma\right)^\ast$\bigg) $\bigg[ \ r^\prime = a [\,_x \alpha  ]\,_x b x_i c \ \wedge \ [\,_x ,  ]\,_x \notin \alpha \ \wedge [\,_x ,  ]\,_x \notin b \ \bigg]$,}
        \item\label{rule:eps}{$deref_0^{r^\prime} \left( x \right) = \varepsilon$ jinak,}
	\item{$deref_1^{r^\prime} \left( a \right) = a$ pro $a \in \Sigma$,}
	\item\label{rule:6}{$deref_1^{r^\prime} \left( y \right) = \varepsilon$ pro $y \in \Gamma$.}
\end{enumerate}
\end{definition}

\begin{definition}\label{def:refword}
Pro referenční slovo $r$ hodnota (anglicky \emph{dereference)} je definována takto:
\begin{equation}D\left(r\right) = deref_1^{r^\prime}  \left( deref_0^{r^\prime}  \left( r^\prime \right) \right),
\end{equation}kde $r^\prime$ je $r$ s~očíslovanými proměnnými.
Dvě referenční slova $r_1$ a $r_2$ jsou \emph{ekvivalentní}, právě když $D\left(r_1\right) = D\left(r_2\right)$.
Hodnota referenčního jazyka $R$ je definována takto:
\begin{equation} D\left(R\right) = \{ D\left(r\right) \mid r \in R\} \end{equation}
Pro regex $\alpha$ \emph{hodnota} je definována následovně:
\begin{equation}L\left(\alpha\right) = D\left(R\left(\alpha\right)\right)\end{equation}
Třída \textsc{Regex} jazyků je definována takto:
\begin{equation}\mathbb{L}_{REGEX} = \bigcup\limits_{\alpha \in RV_{\Sigma, X}} L\left(\alpha\right)\end{equation}
\end{definition}

\begin{example}\label{ex:ref}
Regex $\alpha = x \left( bc \right)^\ast x \{ y a \ y \{ b a^\ast + a\} \ c \} x $ generuje referenční jazyk 
\begin{flalign*} &R\left(\alpha\right) = \{x \left( bc \right)^n  [\,_x y a  [\,_y b a^k]\,_y c ]\,_x x \mid n, k~\in \mathbb{N}_0\} \ \cup \\
 &\{x \left( bc \right)^n  [\,_x y a  [\,_y a]\,_y c ]\,_x x \mid n \in \mathbb{N}_0\}.
\end{flalign*} Referenční slovo $x bcbc [\,_x y a [\,_y ba]\,_y c ]\,_x x \in R\left(\alpha\right)$ odpovídá řetězci 
\begin{flalign*} &D\left(x_1 bcbc [\,_x y_1 a [\,_y ba]\,_y c ]\,_x x_2 \right) =  D\left(bcbc [\,_x  \underbrace{a [\,_y ba]\,_y c }_\text{$\alpha$} ]\,_x  \underline{x_2} \right) =  \\ &bcbcabacabac.\end{flalign*}
Hodnota regexu $\alpha$ se rovná \begin{flalign*}&L\left(\alpha\right) = D\left(R\left(\alpha\right)\right) = \{ \left( bc \right)^n \left( a b a^k c\right)^2 \mid n, k~\in \mathbb{N}_0\} \ \cup \\&\{ \left( bc \right)^n \left(  a a c\right)^2 \mid n \in \mathbb{N}_0\}.\end{flalign*}
\end{example}

Pro porovnání hodnoty referenčního slova se vstupním řetězcem lze použít algoritmus \ref{alg:refword}, který vychází přímo z~definice dereference \ref{def:refword}. Tento algoritmus se chová tak, že projde každý znak $c$ referenčního slova jednou a porovná hodnotu $deref_1^{r^\prime}  \left( deref_0^{r^\prime}  \left( c \right) \right)$ s~odpovídajícími znaky vstupního řetězce. Pokud celkový počet porovnávaných znaků překročí délku řetězce $w$, algoritmus vrátí \texttt{false}. Pro nějaký symbol referenčního slova algoritmus porovná maximálně $\mathcal{O}(|w|)$ znaků (řádky 12--15), celkem tedy algoritmus spotřebuje čas  $\mathcal{O}(|r|\cdot|w|)$. 

\begin{algorithm}
		
  \caption{Porovnání hodnoty referenčního slova s~řetězcem}\label{alg:refword}
    \SetKwInOut{Input}{Vstup}
    \SetKwInOut{Output}{Výstup}
	\DontPrintSemicolon
    \Input{referenční slovo $r$ nad $\Sigma \cup X \cup \Gamma$, vstupní řetězec $w \in \Sigma^\ast$} 
    \Output{$D(r) = w$?}
    $pos : \Gamma \rightarrow \mathbb{N}$; $(\forall x \in \Gamma)$ $pos(x) \gets -\infty$\;
    $j \gets 0$

\For{$i\gets1$ \KwTo $|r|$}{
	\lIf{$r[i] \in \Sigma$}{\lIf{$j \ge |w| \ \vee \ r[i] \ne w[j+1]$}{\KwRet false}
	$j \gets j + 1$}
	\uElseIf{$r[i] \in \Gamma$}{$pos(x) \gets j$\; }
	\uElse{
		$start \gets [\,_{r[i]}$; $end \gets ]\,_{r[i]}$ \;
		\lIf{$pos(start)=-\infty \ \vee \ pos(end) \le pos(start)$}{continue}
		\uElse{
			\For{$k\gets pos(start)+1$ \KwTo $pos(end)$}{
			\lIf{$j \ge |w| \ \vee \ w[k] \ne w[j+1]$}{\KwRet false}
			$j \gets j + 1$
			}
		}
	}
}
\lIf{$j=|w|+1$}{\KwRet true}
\lElse{\KwRet false}
  
\end{algorithm}


Z příkladu \ref{ex:ref} vyplývá, že některá referenční slova je možné převést na jednodušší (kratší), pokud budou vynechány například \uv{nedefinované} proměnné. 

\begin{definition}
Buď $r$ referenční slovo nad ${\Sigma \cup X \cup \Gamma}$. Referenční slovo $r$ obsahuje \emph{referenci na nedefinovanou proměnnou $x \in X$}, právě když platí alespoň jedno z~následujících tvrzení:

	\begin{equation}\label{eq:ref1}\bigg (\exists  a, b \in \left(\Sigma \cup X \cup \Gamma\right)^\ast\bigg) \bigg [ \ r = a x b \ \wedge \ ]\,_x \notin a \ \bigg ]\end{equation}
	\begin{equation}\begin{split}\label{eq:ref2}&\bigg(\exists  \alpha, a, b, c \in \left(\Sigma \cup X \cup \Gamma\right)^\ast\bigg) \bigg [ \ r = a [\,_x \alpha  ]\,_x b x c \ \wedge \ [\,_x, ]\,_x \notin \alpha  \ \wedge \ [\,_x ,  ]\,_x \notin b \ \wedge \\&D \left( \alpha \right) = \varepsilon \ \bigg ] \end{split}\end{equation}
\end{definition}

\begin{example}
	Buď $\Sigma = \{c, d\}$ abeceda, buď $X=\{x, y\}$ množina proměnných. $\Gamma = \{[\,_x , ]\,_x, [\,_y , ]\,_y\}$. Referenční slovo $r = c [\,_x y ]\,_x ddx$ nad $\Sigma\cup X\cup\Gamma$ má dvě zpětné reference na nedefinovanou proměnnou. Reference na $y \in X$ je nedefinovaná, protože neexistuje žádná definice této proměnné zleva (je splňen bod~\ref{eq:ref1}, protože existuje rozklad $r=ayb$ takový, že $a = c [\,_x$ a $]\,_y \notin a$). Zpětná reference $x$ je také nedefinovaná, protože je splněn bod~\ref{eq:ref2}, což znamená, že zleva od tohoto výrazu existuje definice proměnné $x$, ale hodnota tohoto výrazu se rovná $\varepsilon$ (hodnota nedefinované zpětné reference $y$ je prázdné slovo dle pravidla \ref{rule:eps} z~definice hodnoty). Nedefinované proměnné lze z~řetězce odstranit, aniž by se změnila hodnota referenčního slova: $D( c [\,_x y ]\,_x ddx ) = D(c [\,_x ]\,_x d d) = cdd$.
\end{example}

\begin{definition}\label{def:ref}
Referenční slovo $r$ obsahuje \emph{zbytečnou definici proměnné} $x$, právě když platí alespoň jedno z~následujících tvrzení:

	\begin{equation}\label{eq:def1}\bigg (\exists  \alpha, a, b \in \left(\Sigma \cup X \cup \Gamma\right)^\ast\bigg) \bigg [ \ r = a [\,_x \alpha  ]\,_x b \ \wedge \  [\,_x, ]\,_x \notin \alpha  \ \wedge \ x \notin b \ \bigg] \end{equation}
	\begin{equation}\label{eq:def2}\bigg(\exists  \alpha, a, b, c \in \left(\Sigma \cup X \cup \Gamma\right)^\ast\bigg) \bigg [ \ r = a [\,_x \alpha  ]\,_x b  ]\,_x c x \ \wedge \  [\,_x, ]\,_x \notin \alpha  \ \wedge \ x \notin b \ \bigg ]\end{equation}
\end{definition}

\begin{example}
	Referenční slovo $r = c [\,_x c ]\,_x [\,_x d ]\,_x [\,_y x ]\,_y$ nad $\Sigma\cup X\cup\Gamma$ má dvě zbytečné definice, První definice ve výrazu ($[\,_x c ]\,_x$) je zbytečná, protože jediná zpětná reference, která se vyskytuje napravo, odkazuje na definici nacházející bezprostředně po dané definici ($ [\,_x d ]\,_x$), což splňuje bod \ref{eq:def2}. Poslední definice je zbytečná, protože napravo od ní neexistuje žádná reference na proměnnou $y$ (je splněn bod \ref{eq:def1}). Závorky, které ohraničují zbytečnou definici, je možné z~referenčního slova odstranit, přičemž hodnota výsledného řetězce zůstane stejná: $D(c [\,_x c ]\,_x [\,_x d ]\,_x [\,_y x ]\,_y)=D(c c [\,_x d ]\,_x x)=ccdd$.
\end{example}

Z definice \ref{def:refword} plyne, že referenční slovo může \uv{dosvědčit} příslušnost slova k~hodnotě regexu. v~této práci je poprvé zformulováno a dokázáno tvrzení, že pro každé slovo $w$, které je popsáno nějakým regexem $\alpha$, existuje referenční slovo, jehož délka je polynomiální vzhledem k~$|\alpha|^2\cdot|w|$.

\begin{lemma}\label{lem:ref1}
Buď $\alpha \in RV_{\Sigma, X}$, a buď $w \in L(\alpha)$. Potom nutně existuje referenční slovo $r$ nad $\Sigma\cup X \cup\Gamma$ ($\Gamma = \{ [\,_x , ]\,_x \mid x \in X \}$) takové, že $r \in R(\alpha)$, $D(r) = w$ a platí $|r| \le |\alpha|+|\alpha|^2\cdot|w|$.
\end{lemma}

\begin{proof} Trvzení $w \in L(\alpha) \iff \bigg(\exists r \in R(\alpha)\bigg) \ D(r) = w$ plyne z~definice hodnoty regexu. Platí totiž $L(\alpha)=D(R(\alpha))=\{D(r) \mid r \in R(\alpha)\}$. Potom v~referenčním jazyce $R(\alpha)$ existuje nějaké $r$, jehož hodnota se rovná $w$ ($D(r)=w$).  

Druhé tvrzení se rozdělí do dvou případů. 
 \begin{itemize}
	\item{Nechť $\alpha$ neobsahuje žádnou iteraci. z~pozorování \ref{poz:hodnota} vyplývá, že $\alpha$ generuje referenční jazyk $R$, který je také regulárním jazykem nad $\Sigma^\prime = \Sigma \cup X \cup \Gamma$. Potom délka libovolného referenční slova $r \in R(\alpha)$ nemůže přesáhnout délku regexu ($|r| \leq |\alpha|$). Pokud by délka $r$ byla větší, potom musí nějaké dva podřetězce $\varphi$, $\gamma$ ($\varphi \ne \gamma$) z~$r$ odpovídat stejnému podřetězci $\pi$ z~$\alpha$. To ale je možné, jedině když se $\pi$ nachází v~iteraci, což je spor s~předpokladem.}
	\item{Předpokládejme, že $\alpha$ obsahuje alespoň jednu iteraci. Nechť $S$ je souborem všech podřetězců $\alpha$ tvaru $\beta^\ast$. Jelikož $r \in R(\alpha)$, existuje nějaké přiřazení podřetězců z~$r$ výrazům $s_i$ ($s_i^\ast \in S$). Potom lze z~$r$ odstranit podřetězec $\gamma$, který odpovídá nějakému $s_i$ ($s_i^\ast \in S$), pokud hodnota tohoto podřetězce je $\varepsilon$. Podle definice může $\gamma$ obsahovat pouze zbytečné definice, které mají prázdnou hodnotu, a nedefinované reference. Po odstranění všech takových podřetězců z~$r$, jejichž hodnoty jsou prázdné, hodnota výsledného referenčního slova $r^\prime$ zůstane stejná, tedy platí $D(r^\prime)=D(r)=w$. Jelikož byly z~$r$ odstraněny pouze podřetězce odpovídající nějaké iteraci a $\varepsilon$ patří do hodnoty regulárního výrazu $\beta^\ast$ pro libovolné $\beta$, slovo $r^\prime$ bude patřit do referenčního jazyka $R(\alpha)$.  

	Jelikož $r^\prime \in R(\alpha)$, existuje nějaké přiřazení podřetězců z~$r^\prime$ výrazům $s_i$ ($s_i^\ast \in S$). Potom $r_0$ je $r^\prime$, kde všechny takové řetězce jsou opatřeny kulatými závorkami. Nechť tedy $\mathcal{G}$ je strom, pro který platí:
	\begin{itemize}  \item{V kořeni $\mathcal{G}$ je uložen klíč $r_0$.}
				\item{Vrchol $a$ s~klíčem $\pi(a)$ je synem $b$ (dále značeno $s(a, b)$) právě tehdy, když v~$\pi(b)$ existuje podřetězec tvaru $\gamma= (\pi(a))$ a $\gamma$ se nenachází unitř kulatých závorek v~$\pi(b)$.}
				\item{V listech stromu jsou uloženy klíče neobsahující kulaté závorky.}
				\item{Hloubka stromu $\mathcal{G}$ je menší než $\lambda(\alpha)$+1, kde $\lambda(\alpha)$ je hvězdná výška $\alpha$. Předpokládejme, že strom má hloubku $l \ge \lambda(\alpha)+1$, potom musí existovat alespoň jeden uzel na $n$-té úrovni, kde $n = \lambda(\alpha)+2$. To znamená, že kořen stromu má klíč $\pi$ obsahující podřetězec $\gamma$, kde $\gamma$ se nachází uvnitř $\lambda(\alpha)+1$ kulatých závorek. z~toho plyne, že $\gamma$ odpovídá $s_i$ ($s_i^\ast \in S$) a $s_i$ se nachází uvnitř $\lambda(\alpha)+1$ do sebe vnořených iterací v~regexu $\alpha$. Potom z~definice pro hvězdnou výšku $\alpha$ musí platí $\lambda(\alpha) \ge \lambda(\alpha)+1$, což není možné.}
				\item{Počet listu (a tedy i šířka stromu) je menší nebo roven $|w|$. Pokud by strom měl $|w|+1$ listů, potom alespoň jeden z~listů má klíč $\pi$ takový, že $D(\pi)=\varepsilon$, což není možné (všechny takové řetězce byly z~$r^\prime$ odstraněny).}
	\end{itemize}
Kořen $\mathcal{G}$ potom má maximálně $\lambda(\alpha)\cdot|w|$ potomků. Množina potomků pro vrchol $a$ je značena $P(a)$. Délka klíče pro každý vrchol $a$ se rovná $|\pi_{0}(a)| + \sum_{s(i, a)}(|\pi(i)|+2)$, kde $\pi_{0}(a)$ je $\pi(a)$ po odstranění všech podřetězců v~kulatých závorkách. Jelikož $\pi_{0}(a)$ odpovídá podsekvenci $\alpha$ neobsahující iteraci, délka $\pi_{0}(a)$ pro každý vrchol $a$ nepřesáhne $|\alpha|$ a je splněna nerovnost $|\pi(a)| \le |\alpha| + \sum_{s(i, a)}(|\pi(i)|+2)$. v~$r_0$ počet závorek je roven počtu potomků kořene stromu $\varphi$. Potom pro délku referenčního slova $r^\prime$ platí: 
\begin{equation*}\begin{split}|r^{\prime}|&=|\pi(\varphi)|-2|P(\varphi)|=\pi_0(\varphi)+\sum_{i \in P(\varphi)}(|\pi_{0}(i)|+2) - 2|P(\varphi)| \\&= \pi_{0}(\varphi)+\sum_{i \in P(\varphi)}|\pi_{0}(i)| \le |\alpha|+|\alpha|\cdot\lambda(\alpha)\cdot|w| \le |\alpha|+|\alpha|^2\cdot|w|.
\end{split}\end{equation*}
	}
\end{itemize}
\end{proof}

Pro lepší pochopení důkazu lemmatu \ref{lem:ref1} kroky, které se používají pro regex obsahující iteraci, jsou dále demonstrovány na konkretním příkladě.
 
\begin{example}
Nechť $\Sigma = \{a, b\}$ je abeceda a $X=\{y\}$ je množina proměnných. Regex $\alpha = (y^\ast \ y \{a+b\})^\ast$ patří do množiny $RV_{\Sigma, X}$. Hvězdná výška je rovna $\lambda(\alpha) = 2$. Soubor iterací výrazu se rovná $S = \left((y^\ast \ y \{a+b\})^\ast, y^\ast\right)$. Referenční slovo $r = y^{1000} [\,_y a ]\,_y y y [\,_y b ]\,_y [\,_y a ]\,_y \in R(\alpha)$ má hodnotu $w=D(r)=aaaba$. Každá z~první tisíce referencí na $y$ odpovídá $y$ ($y^\ast \in S)$ a je nedefinovaná, proto lze podřetězec $y^{1000}$ z~$r$ odstranit. Pro výsledné referenční slovo $r^\prime = [\,_y a ]\,_y y y [\,_y b ]\,_y [\,_y a ]\,_y$ platí tvrzení $D(r^\prime)=D(r) \ \wedge \ r^\prime \in R(\alpha)$. Potom řetězec $r_0 = ([\,_y a ]\,_y) ((y) (y) [\,_y b ]\,_y) ([\,_y a ]\,_y)$ je $r^\prime$, kde odpovídající řetězce jsou opatřeny kulatými závorkami, jak je popsáno v~důkazu. Graf $\mathcal{G}$ pro $r^\prime$ je zobrazen na obrázku \ref{fig:refproof}. Graf má hloubku $\lambda(\alpha)$ a počet listů je 4 $\le |w|$. Délka referenčního slova $r^\prime$ je rovna $11 \le |\alpha| + |\alpha|^2\cdot|w|=616$, i když $|r| > 616$. 
\end{example}

\begin{figure}[h]
\centering

\begin{tikzpicture}[ edge from parent path={(\tikzparentnode.south) -- (\tikzchildnode.north)}, -]
	\tikzstyle{every node}=[fill=gray!30,rounded corners]
	\tikzstyle{level 1}=[sibling distance=4cm]\tikzstyle{level 2}=[sibling distance=2cm]\tikzstyle{level 3}=[sibling distance=1cm]
	\node {$([\,_y a ]\,_y) ((y) (y) [\,_y b ]\,_y) ([\,_y a ]\,_y)$}
		[level distance=2cm]
		child {node {$\overbrace{[\,_y a ]\,_y}^{\pi_0}$}}
		child {node {$(y) (y) \overbrace{[\,_y b ]\,_y}^{\pi_0}$}
			child {node {$\overbrace{y}^{\pi_0}$}}
			child {node {$\overbrace{y}^{\pi_0}$}}
		}
		child {node {$\overbrace{[\,_y a ]\,_y}^{\pi_0}$}}	
		;
\end{tikzpicture}
\caption{Ukázka grafu $\mathcal{G}$ pro $r^\prime=[\,_y a ]\,_y y y [\,_y b ]\,_y [\,_y a ]\,_y \in R((y^\ast \ y\{a+b\})^\ast)$}\label{fig:refproof}
\end{figure}

\chapter{Algoritmy pro zpracování regexů}
Tato kapitola je věnována problému zpracování regexů. Výše uvedený rozhodovací problém lze definovat takto.

\begin{problem}[Zpracování regexu]\label{prob}
Instance: Regex $\alpha \in RV_{\Sigma, X}$, vstupní řetězec $w \in \Sigma^\ast$.

Otázka: Platí $w \in L\left(\alpha\right)$?
\end{problem}

\begin{theorem}
Problém \ref{prob} je NP-úplný.
\end{theorem}
Těžkost tohoto problému lze ukázat převodem z~problému vrcholového pokrytí \cite[s. 289]{alfred2014algorithms}. I když autor práce používá odlišnou notaci regulárních výrazu se zpětnými referencemi, vyjadřovací síla daného formalismu je rovna vyjadřovací síle regexu \cite[lemma 23 na s. 39]{berglund}. Aho též popisuje jednoduchý nedeterministický algoritmus, pomocí nějž lze vyřešit problém \ref{prob} v~polynomiálním čase. Základní myšlenka spočívá v~nalezení $k$ podřetězců z~$w$, kde $k$~je celkový počet definic a referencí v~$\alpha$. Tímto se problém převede na problém zpracování klasických regulárních výrazů. Algoritmus však nebude nefungovat pro regexy obsahující dílčí výrazy tvaru $\left(w_1 x\{ w_2 \} w_3 \right)^\ast$ (resp. $\left(w_1 x w_2 \right)^\ast$), kde $w_1, w_2, w_3 \in RV_{\Sigma, X}$ \cite[s. 83]{schmidregex}. 
\begin{example}
Pro regex $\alpha=\left(x\{a\} \ b x \right)^\ast$ a $w = abaaba$ algoritmus Aho nalezne dva podřetězce, které odpovídají výrazu $a$ v~definici proměnné $x$ a tyto podřetězce se musí rovnat (definice a reference na tutéž proměnnou). Jelikož počet podřetězců $a$ v~$\alpha$ je 4, celkový počet takových dvojic je roven 6. Po odstranění těchto podřetězců z~$w$ algoritmus vrátí \texttt{true}, pokud $w^\prime \in h( \ (\varepsilon b \varepsilon )^\ast) = h(b^\ast)$.
\begin{itemize}
	\item{$w_0 = \overbrace{a}b\overbrace{a}aba$. $w^\prime = baba \notin h(b^\ast)$. }
	\item{$w_1 =  \overbrace{a}ba \overbrace{a}ba$. $w^\prime = baba \notin h(b^\ast)$. }
	\item{$w_2 =  \overbrace{a}baab \overbrace{a}$. $w^\prime = abba \notin h(b^\ast)$. }
	\item{$w_3 = ab \overbrace{a} \overbrace{a}ba$. $w^\prime = abba \notin h(b^\ast)$.}
	\item{$w_4 = ab \overbrace{a}ab \overbrace{a}$. $w^\prime = abab \notin h(b^\ast)$.}
	\item{$w_5 = aba \overbrace{a}b \overbrace{a}$. $w^\prime = abab \notin h(b^\ast)$.}
\end{itemize} 
Algoritmus vrátí nesprávný výsledek, protože $abaaba \in L(\alpha)$. Problém spočívá v~tom, že nelze předem určit počet podřetězců z~$w$, které je potřeba přiřadit nějakým proměnným v~regexu, pokud vstupní regex obsahuje definice nebo zpětné reference v~iteraci. 
\end{example} 

Dá se však ukázat, že problém je v~NP, i když regex obsahuje definici proměnné v~iteraci. v~této práce je poprvé popsán přístup k~dokazování založený na pojmu referenčního slova.

\begin{theorem}
Problém \ref{prob} patří do třídy NP.
\end{theorem}
\begin{proof} Jednou z~možností, jak by mohl vypadat certifikát kladné odpovědí, je nějaké referenční slovo $r$ nad $\Sigma \cup X \cup \Gamma$ ($\Gamma = \{ [\,_x , ]\,_x \mid x \in X \}$). Pokud $w \in L\left(\alpha\right)$, podle lemmatu \ref{lem:ref1} musí nutně existovat nějaké referenční slovo, pro něž platí $w = D\left(r\right)$, $r \in R\left(\alpha\right)$ a $ |r| \le |\alpha|+|\alpha|^2\cdot|w|$, což znamená, že délka tohoto certifikátu je polynomiální vzhledem k~vstupu.

Lze také ukázat, jak tento polynomiální certifikát dosvědčí, že $w$ odpovídá regexu $\alpha$. k~tomu stačí ověřit, že referenční slovo patří k~referenčnímu jazyku $R\left(\alpha\right)$ a hodnota $D\left(r\right)$ se rovná $w$. z~pozorování \ref{poz:hodnota} vyplývá, že rozhodovací problém jestli platí $r \in R(\alpha)$ je možné převést na problém zpracování regulárních výrazů, který lze vyřešit v~čase $\mathcal{O}\left(|\alpha| \cdot |r|\right)$ (\cite[s. 282--285]{alfred2014algorithms}). Zbývá ověřit, jestli se hodnota $D\left(r\right)$ rovná $w$. Hodnotu $D\left(r\right)$ tedy lze porovnat se vstupním slovem pomocí algoritmu \ref{alg:refword} v~čase $\mathcal{O}(|r|\cdot|w|)$. Jelikož ověření lze provést deterministicky v~polynomiálním čase vzhledem k~délce vstupu, problém 3.1 patří do třídy NP.
\end{proof}

Všechny algoritmy pro zpracování regexů, kterým je věnován zbytek této kapitoly, se skládají ze dvou části: konstrukce automatu, který přijímá jazyk $L\left(\alpha\right)$, a simulace jeho běhu pro vstupní slovo $w$ (viz obrázek \ref{fig:engine}). v~dalších sekcích jsou popsány výpočetní modely přijímající libovolný \textsc{Regex} jazyk a algoritmy pro převod regexů na tyto modely.
\tikzstyle{block} = [draw, rectangle, 
    minimum height=3em, minimum width=6em]
\tikzstyle{input} = [coordinate]
\tikzstyle{output} = [coordinate]
\tikzstyle{pinstyle} = [pin edge={to-,thin,black}]
\begin{figure}[h]
\centering
\begin{tikzpicture}[auto, node distance=3cm,>=latex']
	
    \node [input] (regex){};
    \node [block, right of=regex] (lexer) {lexer};
    \node [block, right of=lexer] (parser) {parser};
    \node [block, below=1cm of parser] (gen) {$\substack{\text{regex matcher} \\ \text{generator}}$};
    \node [block, below=0.75cm of gen] (match) {$\substack{\text{regex} \\ \text{matcher}}$};
    \node [input, left of=match] (word){};
    \node [output, right of=match] (output) {};
    \draw [->] (lexer) -- (parser);
    \draw [draw, ->] (regex) -- node {$\alpha$} (lexer);
    \draw [draw, ->] (word) -- node {$w$} (match);
    \draw [draw, ->] (match) -- node {yes/no} (output);
    \draw [draw, ->] (parser) -- node {AST for $\alpha$} (gen);
    \draw [draw, ->] (gen) -- (match);

\end{tikzpicture}
\caption{Struktura prostředku pro zpracování regexu}\label{fig:engine}
\end{figure}
\section{Parsování regexů}
Algoritmy pro převod nezpracovávají přímo na vstupu znaky regexu, nýbrž strukturu tohoto výrazu. Cílem této sekce je ukázat, jak by mohla vypadat struktura regexu, a popsat následující fáze \uv{překladu} výrazu: lexikální, syntaktickou a sémantickou analýzu.

\subsection{Lexikální analýza}
Cílem lexikální analýzy je konverze vstupní posloupnosti na lexikální symboly (dále jen \emph{tokeny}). Jazyk tokenů lze popsat regulární gramatikou a lexikální analyzátor (též \emph{lexer}) je pak tvořen deterministickým konečným automatem. Pokud lexer nerozpozná nějaký vstupní symbol, vznikne lexikální chyba. 

V tabulce \ref{tab:lex} je uvedeno, který token a atribut vrátí lexer pro jednotlivé lexémy.

\begin{table}
\begin{center}
 \begin{tabular}{|l|r|r|} 
 \hline
\textbf{Lexém} & \multicolumn{1}{|l|}{\textbf{Token}}  & \multicolumn{1}{|l|}{\textbf{Atribut}}  \\ [0.5ex] 
 \hline\hline
znak abecedy & $atom$ & ASCII hodnota \\
 \hline
$\varepsilon$ nebo $\varnothing$ & $atom$ & ‚$\varepsilon$‘ nebo ‚$\varnothing$‘ \\
 \hline
proměnná & $var$ & název proměnné \\
 \hline
+ & $union$ &  - \\
 \hline
* & $iter$ & - \\
 \hline
$\{$ nebo $\}$ & $\{$ nebo $\}$ & - \\ 
 \hline
$($ nebo $)$ & $($ nebo $)$ & - \\ 
 \hline
\end{tabular}
\end{center}
\caption{\label{tab:lex} Lexikální elementy a jejich reprezentace}
\end{table}

\subsection{Návrh gramatiky}\label{sec:gram}
Aby bylo možné přijímat jazyk regexů, je vhodné pro něj zkonstruovat gramatiku. Bezkontextová gramatika generující regexy z~$RV_{\Sigma, X}$ by mohla vypadat následovně:

$G = \left(\{A, B, C, D\}, \{atom, var, \{, \}, \left(, \right), union, iter\}, P, A\right)$, kde:
\begin{flalign*}
P = \ \ &\{A \rightarrow B \ union \ A \ | \ B,\\
      &B \rightarrow C B \ | \ C,\\
      &C \rightarrow D \ iter \ | \ D,\\
      &D \rightarrow atom \ | \ var \ | \ var \{ A \}  \ | \left( A \right) \}
\end{flalign*}
Uvedená gramatika podporuje všechny operace a operátory mají rozdílnou prioritu. Priorita ovlivňuje v~jakém pořadí je výraz vyhodnocován.
\subsection{Syntaktická analýza}\label{sec:synt}
Cílem syntaktické analýzy je určit gramatickou strukturu vstupu na základě předem dané gramatiky. Syntaktický analyzátor (též \emph{parser}) dostane na vstup řetězec tokenů a hledá derivační strom k~tomuto řetězci. Pokud žádný derivační strom nenajde, vznikne syntaktická chyba.

V této práci se používá $LL(1)$ analýza jako metoda pro syntaktický analyzátor. Před zpracováním řetězce tokenů je nutné ověřit, zda daná gramatika je LL(1) (v opačném případě hrozí nekonečná rekurze). Gramatika $G$ z~sekce~\ref{sec:gram} není LL(1), protože tato gramatika má \emph{first-first konflikty} v~rozkladové tabulce pro neterminální symboly $A, B, C$ a terminály $atom, var, ($. K~odstranění konfliktů lze použít levou faktorizaci.
Výsledná ekvivalentní gramatika $G^{\prime}$ je uspořádanou čtveřicí:

	$\left(\{A, A^\prime, B, B^\prime, C, C^\prime, D, F^\prime\}, \{atom, var, \{, \}, \left(, \right), union, iter\},  P^\prime, A\right)$, kde:
\begin{flalign}
P^\prime = \ &\{A  \rightarrow B A^\prime, \label{g:1}\\  
		 &A^\prime \rightarrow union \ A, \label{g:2}\\ 
		 &A^\prime \rightarrow \varepsilon, \label{g:3}\\
		 &B  \rightarrow C B^\prime, \label{g:4}\\
		 &B^\prime \rightarrow B, \label{g:5}\\
		 &B^\prime \rightarrow \varepsilon, \label{g:6}\\
		 &C \rightarrow D C^\prime, \label{g:7}\\
		 &C^\prime \rightarrow iter, \label{g:8}\\
		 &C^\prime \rightarrow \varepsilon, \label{g:9}\\
		 &D \rightarrow atom, \label{g:10}\\
		 &D  \rightarrow var \ F^\prime, \label{g:11}\\
  		 &D  \rightarrow \left( A \right), \label{g:12}\\
		 &F^\prime  \rightarrow \{ A \}, \label{g:13}\\
		 &F^\prime  \rightarrow \varepsilon\ \label{g:14}\} 
\end{flalign}
		
Rozkladová tabulka pro tuto gramatiky je znázorněna pomocí tabulky \ref{tab:rozk}.

\begin{table}
\begin{center}
 \begin{tabular}{|l|c c c c c c c c c|} 
 \hline
  &  $\mathbf{atom}$ & $\mathbf{var}$ & $\mathbf{\{}$ & $\mathbf{\}}$ & $\mathbf{(}$ & $\mathbf{)}$ & $\mathbf{union}$ & $\mathbf{iter}$ & $\mathbf{\varepsilon}$  \\ [0.5ex] 
 \hline\hline
$A$ & \ref{g:1} & \ref{g:1} & & & \ref{g:1} & & & &  \\
\hline
$A^\prime$ & & & &\ref{g:3} & & \ref{g:3} & \ref{g:2} & &\ref{g:3} \\
\hline 
$B$ & \ref{g:4} & \ref{g:4} & & & \ref{g:4} & & & &  \\
\hline
$B^\prime$ & \ref{g:5} &  \ref{g:5}  & &\ref{g:6} &  \ref{g:5} & \ref{g:6} & \ref{g:6} & &\ref{g:6} \\
\hline 
$C$ & \ref{g:7} & \ref{g:7} & & & \ref{g:7} & & & &  \\
\hline
$C^\prime$ & \ref{g:9} &  \ref{g:9}  & &\ref{g:9} & \ref{g:9} & \ref{g:9} & \ref{g:9} & \ref{g:8} &\ref{g:9} \\
\hline 
$D$ & \ref{g:10} & \ref{g:11} & & & \ref{g:12} & & & &  \\
\hline
$F^\prime$ & \ref{g:14} &  \ref{g:14}  & \ref{g:13} &\ref{g:14} & \ref{g:14} & \ref{g:14} & \ref{g:14} & \ref{g:14} &\ref{g:14} \\
\hline
\end{tabular}
\end{center}
\caption{\label{tab:rozk} Rozkladová tabulka pro gramatiku generující regexy}
\end{table}

\subsection{Reprezentace regexu abstraktním syntaktickým stromem}
Pro reprezentaci regexu se nabízí použít syntaktický strom, jehož vnitřní uzly představují nějaký operátor (zřetězení, sjednocení, iteraci nebo definici proměnné). Koncové uzly reprezentují jednoduché operandy (atomy a proměnné). Pro regexy stačí pět typů uzlů:
\begin{itemize}
\item unární operátor (iterace)
\item binární operátor (zřetězení a sjednocení)
\item definice proměnné
\item atom
\item zpětná reference
\end{itemize}

Na obrázku \ref{fig:ast} je zobrazen příklad AST pro regex $x\{a^\ast+b^\ast\} \ x \ (yb \ y \{b^\ast\})^\ast$.

\begin{figure}[h]
\centering

\begin{tikzpicture}[edge from parent path={(\tikzparentnode.south) .. controls +(0,-0.4) and +(0,0.4).. (\tikzchildnode.north)}, -]
	\tikzstyle{every node}=[fill=gray!30,rounded corners]
	\tikzstyle{level 1}=[sibling distance=6cm]\tikzstyle{level 2}=[sibling distance=4cm]\tikzstyle{level 3}=[sibling distance=2cm]
	\node {$\cdot$}
		[level distance=1cm]
		child {node {$x\{\}$}
			child {node {$+$}
				child {node {$\ast$}
					child {node {$a$}}
				}
				child {node {$\ast$}
					child {node {$b$}}
				}
			}
		}
		child {node {$\cdot$}
			child {node {$x$}}
			child {node {$\ast$}
				child {node {$\cdot$}
					child {node {$y$}}
					child {node {$\cdot$}
						child {node {$b$}}
						child {node {$y\{\}$}
							child {node {$\ast$}
								child {node {$b$}}
							}
						}
					}
				}
			}
		};
\end{tikzpicture}
\caption{Ukázka AST pro výraz  $x\{a^\ast+b^\ast\} \ x \ (yb \ y \{b^\ast\})^\ast$}\label{fig:ast}
\end{figure}

\subsection{Sémantická analýza}\label{sec:semantic}
Sémantická analýza se obvykle provádí zároveň se syntaktickou analýzou. Úkolem sémantické analýzy je sestrojit abstraktní syntaktický strom, který uchovává všechny podstatné informace obsažené v~regexu s~ohledem na jeho strukturu. 

Sémantický analyzátor může být vytvořen podle L-atributové gramatiky se vstupní gramatikou $G^\prime$ (viz sekci \ref{sec:synt}). Všem neterminálům je přiřazen syntetizovaný atribut $snode$, jehož hodnotou bude ukazatel na vytvořený strom. Dědičný atribut $dnode$ u neterminálních symbolů $A^\prime, B^\prime, C^\prime$ obsahuje ukazatel na vytvořený podstrom pro levý operand. Pro terminální symbol $atom$ syntetizovaný atribut $svalue$ odpovídá hodnotě elementárního výrazu a atribut $svar$ pro symbol $var$ obsahuje název proměnné.
Posloupnost sémantických akcí pro atributovou gramatiku je definována pomocí tabulky \ref{tab:sem}.

\begin{table}
\begin{center}
 \begin{tabular}{|lcl|p{90mm}|} 
\hline
\multicolumn{3}{|p{30mm}|}{\textbf{Syntaktické \newline pravidlo}}&\multicolumn{1}{|l|}{\textbf{Sémantická pravidla}} \\
\hline\hline
$A$  &  $\rightarrow$ & $B A^\prime$ & $A^\prime.dnode=B.snode \newline A.snode= A^\prime.snode$ \\  
\hline
$A^\prime$ & $\rightarrow$ & $union \ A$ & $A^\prime.snode=new \ BinOp(union, A^\prime.dnode, A.snode)$\\ 
\hline
$A^\prime$ & $\rightarrow$ & $\varepsilon$ & $A^\prime.snode=A^\prime.dnode$\\
\hline
$B$ & $\rightarrow$ & $C B^\prime$ &  $B^\prime.dnode=C.snode \newline  B.snode= B^\prime.snode$ \\
\hline
$B^\prime$ &$\rightarrow$ & $B$ &  $B^\prime.snode=new \ BinOp(concat, B^\prime.dnode, B.snode)$\\
\hline
$B^\prime$ & $\rightarrow$ & $\varepsilon$ &$B^\prime.snode=B^\prime.dnode$\\
\hline
$C $&$\rightarrow$& $D C^\prime$ & $C^\prime.dnode=D.snode \newline C.snode= C^\prime.snode$\\
\hline
$C^\prime$ &$\rightarrow$& $iter$ & $C^\prime.snode=new \ UnOp(iter, C^\prime.dnode)$\\
\hline
$C^\prime$ &$\rightarrow $&$\varepsilon$ &$C^\prime.snode= C^\prime.dnode$ \\
\hline
$D$ &$\rightarrow$ &$atom$ & $D.snode=new \ Atom(atom.svalue)$\\
\hline
$D$ & $\rightarrow$&$ var \ F^\prime$ & $F^\prime.dnode=new \ Var(var.svar) \newline  D.snode=F^\prime.snode$\\
\hline
$D$ & $\rightarrow$ &$\left( A \right)$& $D.snode=A.snode$ \\
\hline
$F^\prime$ & $\rightarrow$&$ \{ A \}$ & $F^\prime.snode = new \ Def(F^\prime.dnode, A.snode)$ \\
\hline
$F^\prime$ & $\rightarrow$& $\varepsilon$ & $F^\prime.snode = F^\prime.dnode$ \\
\hline

\end{tabular}
\end{center}
\caption{\label{tab:sem} Sémantická pravidla pro vytvoření AST}
\end{table}
  

\section{Vícepáskový lineárně omezený Turingův stroj}\label{sec:turmac}

V této sekci je definován vícepáskový lineární omezený Turingův stroj a jsou popsány jeho vlastnosti (vycházeno z~\cite{hopcroft} a \cite{sestakova}).
Pod pojmem \uv{Turingův stroj} je v~textu myšlena nedeterministická verze tohoto výpočetního modelu.  

\begin{definition}
\emph{Turingův stroj s~k páskami}, zkráceně \emph{TS($k$)}, je formálně definován jako sedmice $\mathcal{M} = \left(Q, \Sigma, G, \delta, q_0, B, F\right)$, kde:
\begin{itemize}
	\item{$Q$ je konečná neprázdná množina stavů,}
	\item{$G$ je konečná neprázdná pracovní abeceda,}
	\item{$\Sigma$ je konečná vstupní abeceda ($\Sigma \subseteq G$),}
	\item{$\delta$ : $\left(Q \setminus F\right) \times  G^k \rightarrow \wp\left( Q\times \left(G \times \{-1, 0, 1\}\right)^k \right)$ je přechodová funkce,}
	\item{$q_0 \in Q$ je počáteční stav,}
	\item{$B \in \left(G\setminus\Sigma\right)$ je prázdný symbol,}
	\item{$F \subseteq Q$ je konečná množina koncových stavů.}
\end{itemize}
\end{definition}
Definice přechodové funkce nám říká, že je-li vícepáskový TS v~nekoncovém stavu a čtecí hlavy na páskách ukazují na nějaké symboly z~pracovní abecedy, poté přejde do dalšího stavu, na každou pásku zapíše nějaký symbol a každou čtecí hlavu posune vlevo, vpravo nebo zůstane na místě.

\begin{definition}
Nechť $\mathcal{M} = \left(Q, \Sigma, G, \delta, q_0, B, F\right)$ je Turingův stroj s~$k$ páskami.
\emph{Konfigurace} $\mathcal{M}$ je trojice $\left(q, \langle w_1, \dots, w_k\rangle,  \langle i_1, \dots, i_k\rangle\right)$, kde:
\begin{itemize}
	\item{$q$ je aktuální stav,}
	\item{$w_i$ je obsah $i$-té pásky,}
	\item{$i_j$ je pozice čtecí hlavy na $j$-té pásce.}
\end{itemize}

Počáteční konfigurace $\mathcal{M}$ pro vstup $w$ je konfigurace $$\left(q_0, \langle w, B^{|w|}, \dots, B^{|w|} \rangle,  \langle 0, \dots, 0\rangle\right)$$

\emph{Přechodem} $\mathcal{M}$ se nazývá binární relace $\vdash_\mathcal{M}$ na množině konfigurací definovaná následovně:
\begin{equation}
\begin{split}
&\left(q, \langle w_0 \dots w_{i_1-1}w_{i_1}w_{i_1+1} \dots w_n, \dots \rangle,  \langle i_1, \dots \rangle\right) \vdash_\mathcal{M} \\
&\left(p, \langle w_0 \dots w_{i_1-1}x_1w_{i_1+1} \dots w_n,  \dots \rangle,  \langle i_1+j_1, \dots \rangle \right) \\
&\iff \left(p, \langle\left(x_1, j_1\right),  \dots \rangle\right) \in \delta\left(q, \langle w_{i_1}, \dots \rangle \right)
\end{split}
\end{equation}


\emph{Jazyk přijímaný} $\mathcal{M}$ je množina
\begin{equation}
	\begin{split}
&L\left(\mathcal{M}\right) =\bigg \{ w \mathrel{\bigg|} \left(\exists p \in F \right)  \left(\exists x_1,\dots, x_{k-1} \in G^\ast \right) \left(\exists i_1, \dots, i_{k} \in \mathbb{N}_0 \right) \\ 
&\Big [ \left(q_0, \left(w, \varepsilon, \dots, \varepsilon \right),  \left(0, \dots, 0\right)\right) \vdash_{\mathcal{M}}^{\ast} \left(p, \left(B^{|w|}, x_1,\dots, x_{k-1} \right),  \left(i_1, \dots, i_{k}\right)\right) \Big ] \bigg\}
\end{split}
\end{equation}
\end{definition}

V této práci se používá graf přechodů pro znázornění přechodové funkce automatu. Hrany grafu reprezentují přechody a jsou ohodnoceny posloupností $k$ trojic. Každá trojice odpovídá operacím, které se provádějí s~$i$-tou páskou (kde $i$ je pozice trojice v~posloupnosti), a skládá se ze čteného symbolu, symbolu k~zápisu a pohybu čtecí hlavy. Na obrázku \ref{fig:trans} je zobrazen přechod ze stavu $q$ do $p$, po němž automat přečte z~0. pásky symbol $a$, zapíše na ni blank symbol a posune čtecí hlavu vpravo. 

\begin{figure}[ht] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
	\centering % centers the figure
	\begin{tikzpicture}% tikz code goes here
		\node[state] (q) {$q$};
		\node[state, right=7cm of q] (p) {$p$};
		\draw  (q) edge[below] node{$\big\langle \underbrace{a}_{\substack{\text{čtený} \\ \text{symbol}}},  \underbrace{B}_\text{zápis},  \underbrace{1}_{\substack{\text{pohyb} \\ \text{čtecí hlavy}}}\big\rangle, \dots$} (p);
	\end{tikzpicture}
	\caption{Znázornění přechodové funkce $TS(k)$ pomocí grafu přechodů}
	\label{fig:trans}
\end{figure}

\begin{algorithm}
		
  \caption{Simulace vícepáskového TS}\label{alg:tmsim}
    \SetKwInOut{Input}{Vstup}
    \SetKwInOut{Output}{Výstup}
	\DontPrintSemicolon
    \Input{$TS(k)$ $M = \left(Q, G, B, \Sigma, \delta, q_0, F\right)$, vstupní slovo $w$ } 
    \Output{$w \in L(M)$?}
    $tapes[0,\dots,k-1][1,\dots,|w|]$; $tapes[0]\gets w$\;
    $pos[0\dots,k-1]$ ; ($\forall i \in \{0,\dots, k-1\}$) $pos[i]\gets0$\;
    $curState \gets q_0$ \;  
\SetAlgoLined
\SetKwFunction{Build}{accepts}
\SetKwFunction{Trans}{getTrans}
\SetKwFunction{Cp}{getCopy}
\SetKwFunction{Exec}{execTrans}
\SetKwProg{Def}{def}{}{}
\Def{\Build{$curState$, $tapes$, $pos$}}{
	\lIf{$curState \in F \ \wedge \ tapes[0]=B^{|w|+2}$}{\KwRet true}
	$transitions \gets$ \Trans{$curState$, $tapes$, $pos$}\;
	\For{$i\gets1$ \KwTo $|transitions|$}{
	$tapesCopy \gets $\Cp{$tapes$}\;
	$posCopy  \gets $\Cp{$pos$}\;
	$stateCopy \gets $\Cp{$curState$}\;
	\Exec{$transitions[i]$, $stateCopy$, $tapesCopy$, $posCopy$}\;
	\uIf{\Build{$stateCopy$, $tapesCopy$, $posCopy$}}{\KwRet true}
	}
	\KwRet false\;
}
\

\KwRet \Build{$curState$, $tapes$, $pos$}\;
\end{algorithm}

\begin{theorem}\label{thm:multitape}
Pro každý $k$-páskový TS existuje ekvivalentní jednopáskový TS.
\end{theorem}
Důkaz věty \ref{thm:multitape} je podrobně uveden v~\cite[s. 337--338]{hopcroft}.

\begin{definition}
\emph{Lineárně omezený Turingův stroj}, zkráceně LOTS, je Turingův stroj, který nemůže překročit délku $k$-násobku vstupního slova pro nějaké $k \ge 1$.
\end{definition}

Algoritmus \ref{alg:tmsim} lze použít pro simulaci výpočtu vícepáskového TS pro řetězec~$w$. Funkce $accepts$ má tři vstupní parametry, které jednoznačně určují aktuální konfiguraci TS. Na začátku se zavolá tato funkce se vstupními parametry, které odpovídají počáteční konfigurace automatu. Funkce vrátí hodnotu $true$, pokud je na vstupu koncová konfigurace. Jinak pro každý přechod algoritmus vytvoří novou konfiguraci a zavolá rekurzivně funkci $accepts$. 

\section{Algoritmus pro převod regexu na vícepáskový LOTS}\label{sec:turing}
V této sekci je ukázáno, jak lze pro libovolný regex $\alpha$ sestrojit vícepáskový lineárně omezený TS, který přijímá jazyk $L\left(\alpha\right)$.
Základní myšlenka konstrukce byla převzata z~\cite[s. 8]{campeanu}, kde je popsán převod semiregexů na vícepáskový TS. Autor práce zmíněný algoritmus rozšířil na množinu regexů. Při modifikaci byl brán zřetel především na to, že se v~regexech oproti semerigexům může vyskytnout několik definic téže proměnné ($\dots x\{\dots\}\dots x\{\dots\}\dots$).

Algoritmus \ref{alg:turing} dostane AST pro regex $\alpha$ na vstupu. 
Potom výstupem algoritmu je $TS(k+1)$ ($k=|var(\alpha)|$), který má následující vlastnosti:
\begin{itemize}
	\item{Na počátku výpočtu je na 0. pásce zapsán vstupní řetězec. Této pásce se také říká \emph{vstupní}. Ostatní (pracovní) pásky jsou vyplněny prázdnými symboly. Počáteční konfigurace tedy je $$\left(q_{start}, \langle BwB, B^{|w|+2}, \dots, B^{|w|+2} \rangle,  \langle 1, \dots, 1\rangle\right)$$}
	\item{Pro nějaké $i \in \{1, \dots, k\}$ $i$-tá páska odpovídá nějaké proměnné $x$ v~$\alpha$. V~kroku výpočtu, kdy symboly na vstupní pásce odpovídají dílčímu výrazu v~definici proměnné $x$, automat odstraní symboly z~$i$-té pásky a začne kopírovat znaky ze vstupní pásky na $i$-tou, dokud nenarazí na poslední symbol odpovídající tomuto výrazu. Pokud se čtecí hlava na vstupní pásce ukazuje na začátek řetězce, který odpovídá zpětné referenci na $x$, TS posune čtecí hlavu na $i$-té pásce na začátek a začne porovnávat obsah $i$-té pásky se vstupní.}
\end{itemize} 

Nechť $num$ je zobrazení z~$var(\alpha)$ do množiny $\{1, \dots, k\}$ takové, že pro každé dvě různé proměnné $x, y$ v~$\alpha$ platí $num(x) \ne num(y)$. Potom $i$-tá páska odpovídá proměnné označené číslem $i$. Nechť tedy $T[1, \dots, k]$ je tabulka, která nabývá hodnot z~$\{0,1\}$. Potom $T[i] = 1$, právě když se na $i$-tou pásku kopíruje obsah 0. pásky, jinak $T[i] = 0$. 

\begin{algorithm}
  \caption{Převod regexu na vícepáskový LOTS}\label{alg:turing}
    \SetKwInOut{Input}{Vstup}
    \SetKwInOut{Output}{Výstup}
	\DontPrintSemicolon
    \Input{AST reprezentující regex $\alpha \in RV_{\Sigma, X}$ s~kořenem $\varphi$} 
    \Output{$(k+1)$-páskový LOTS $M$ takový, že $L(M)=L(\alpha)$} \tcc{$k$ je počet proměnných v~$\alpha$ ($k = |var(\alpha)|$)}
    $num : X \rightarrow \{1, \dots, k\}$; ($\forall x, y \in X$)  $num(x)=num(y) \Rightarrow x=y$\; ($\forall i \in \{1, \dots, k\}$) $ T[i] \gets 0$\;
    $Q \gets \{q_{start}, q_{end}\}$; $F \gets \{q_{end}\}$; $G \gets \Sigma \cup \{B\}$\;
	
\SetAlgoLined
\SetKwFunction{Build}{build-TM}
\SetKwFunction{BuildM}{modify}
\SetKwProg{Def}{def}{}{}
\Def{\Build{$\beta$, $q_{start}$, $q_{end}$}}{

\uIf{$type(\beta) = atomic$}{
  \lIf{$\beta.value = \varepsilon$}{uprav $\delta$ podle (\ref{itm:eps})}
  \lElseIf{$\beta.value = \varnothing$}{ $p \notin Q$; $Q \leftarrow Q \cup \{p\}$\;
uprav $\delta$ podle (\ref{itm:nothing})}
  \lElse{uprav $\delta$ podle (\ref{itm:symbol})
  }
	  }
	\uElseIf{$type(\beta) = union$}{
	$q_{start}^{l}, q_{start}^{r}, q_{end}^{l}, q_{end}^{r} \notin Q$; $Q \leftarrow Q \cup \{q_{start}^{l}, q_{start}^{r}, q_{end}^{l}, q_{end}^{r}\}$\;
	 uprav $\delta$ podle (\ref{itm:union})\;
	 \Build{$\beta.left$, $q_{start}^{l}$, $q_{end}^{l}$}; \Build{$\beta.right$, $q_{start}^{r}$, $q_{end}^{r}$}
       }
	\uElseIf{$type(\beta) = concatenation$}{
	$q_{start}^{l}, q_{start}^{r}, q_{end}^{l}, q_{end}^{r}, q_{mid}  \notin Q$; $Q \leftarrow Q \cup \{q_{start}^{l}, q_{start}^{r}, q_{end}^{l}, q_{end}^{r}, q_{mid}\}$\;
		uprav $\delta$ podle \ref{itm:concat}\;
		\Build{$\beta.left$, $q_{start}^{l}$, $q_{end}^{l}$}; \Build{$\beta.right$, $q_{start}^{r}$, $q_{end}^{r}$}
	}

	\uElseIf{$type(\beta) = iteration$}{
	$q_{start}^{\alpha}, q_{end}^{\alpha}  \notin Q$; $Q \leftarrow Q \cup \{q_{start}^{\alpha}, q_{end}^{\alpha}\}$\;
		uprav $\delta$ podle (\ref{itm:iter})\;
		\Build{$\beta.inner$, $q_{start}^{\alpha}$, $q_{end}^{\alpha}$}\;
	}

	\uElseIf{$type(\beta) = definition$}{
       $p, q_{start}^{\alpha}, q_{end}^{\alpha}  \notin Q$; $Q \leftarrow Q \cup \{p, q_{start}^{\alpha}, q_{end}^{\alpha}\}$\;
		uprav $\delta$ podle (\ref{itm:def})\;
		$T[num(\beta.var)] \gets 1$\;
		\Build{$\beta.inner$, $q_{start}^{\alpha}$, $q_{end}^{\alpha}$}\;
		$T[num(\beta.var)] \gets 0$\;
	}

	\uElseIf{$type(\beta) = reference$}{
       $p, q  \notin Q$\; $Q \leftarrow Q \cup \{p, q\}$\;
		 uprav $\delta$ podle (\ref{itm:ref})\;
	}
}
\

\Build{$\varphi$, $q_{start}$, $q_{end}$}\;
$\mathcal{M} =  (Q, \Sigma, G, \delta, q_{start}, B, F)$\;
\KwRet $\mathcal{M}$\;
  
\end{algorithm}

Algoritmus prochází rekurzivně uzly stromu a přidává nové stavy a odpovídající přechody pro daný typ uzlu. Konstrukce vícepáskového Turingova stroje pro atomy a regulární operace vychází z~podobné myšlenky jako Thompsonův algoritmus pro převod regulárních výrazů na NKA. Výsledný Turingův stroj má počáteční stav $q_{start}$ a jediný koncový stav $q_{end}$. Postup konstrukce je popsán pro jednotlivé uzly takto:
\begin{enumerate}
 \item{Prvním typem uzlu je elementární výraz. Může nastat jeden z~následujících případů:}
   \begin{enumerate}
   \item \label{itm:eps}{Uzel reprezentuje prázdný řetězec. Potom se přidají \uv{$\varepsilon$-přechody} ze stavu $q_{start}$ do stavu $q_{end}$. 
	 Pod pojmem \uv{$\varepsilon$-přechod} je myšleno přechod, při kterém stroj přečte a zapíše tentýž symbol na každou pásku a čtecí hlavy na každé pásce zůstanou na místě. Počet přechodů je roven počtu $(k+1)$-členných variací s~opakováním z~$|G|$ prvků ($|G|^{k+1}$).

	Pro $\forall x_0, \dots, x_{k} \in G$ se přechodová funkce modifikuje následovně (viz obrázek \ref{fig:eps}):
	\begin{equation*}\begin{split}\delta(q_{start}, \langle  x_0, \dots, x_{k}\rangle)\leftarrow &\delta(q_{start}, \langle  x_0, \dots, x_{k}\rangle)  \ \cup \\&\{(q_{end}, \langle x_0, 0\rangle, \dots, \langle x_k, 0\rangle)\}.\end{split}\end{equation*}
	}
\begin{figure}[ht] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
	\centering % centers the figure
	\begin{tikzpicture}[scale=0.8]
		\tikzstyle{every node}=[scale=0.8]
		\node[state, dashed] (start) {$q_{start}$};
		\node[state, dashed, right=4.5cm of start] (end) {$q_{end}$};
		\draw  	(start) edge[above] node{$\Big\langle x_0, x_0, 0\Big\rangle, \dots, \overbrace{\Big\langle x_i, x_i, 0\Big\rangle}^{T[i] \in \{0, 1\}} \dots$} (end);
	\end{tikzpicture}
	\caption{Ukázka sestavení $TS(k+1)$ při průchodu uzlem reprezentujícím výraz $\varepsilon$}
	\label{fig:eps}
\end{figure}
     \item \label{itm:nothing}{Dalším typem uzlu je prázdný regulární výraz. Pro tento uzel se do množiny stavů přidá nový stav $p$. Přidají se \uv{$\varepsilon$-přechody} ze stavu $q_{start}$ do stavu $p$. Stav $p$ zde zastává funkci \uv{nulového} stavu (přechodová funkce $\delta$ neobsahuje žádný přechod ze stavu $p$ do nějakého dalšího stavu).

	Pro $\forall x_0, \dots, x_{k} \in G$ se provede úprava přechodové funkce automatu následovně (viz obrázek \ref{fig:nothing}):
	\begin{flalign*}\delta(q_{start}, \langle  x_0, \dots, x_{k}\rangle)\leftarrow&\delta(q_{start}, \langle  x_0, \dots, x_{k}\rangle) \ \cup \\ &\{(p, \langle x_0, 0\rangle, \dots, \langle x_k, 0\rangle)\}.\end{flalign*}
	}	
	\begin{figure}[ht] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
	\centering % centers the figure
	\begin{tikzpicture}[scale=0.8]
		\tikzstyle{every node}=[scale=0.8]
		\node[state, dashed] (start) {$q_{start}$};
		\node[state, right of=start] (p) {$p$};
		\node[state, dashed, right=1.5cm of p] (end) {$q_{end}$};
		\draw  	(start) edge[above] node{$\Big\langle x_0, x_0, 0\Big\rangle, \dots, \overbrace{\Big\langle x_i, x_i, 0\Big\rangle}^{T[i] \in \{0, 1\}} \dots$} (p);
	\end{tikzpicture}
	\caption{Ukázka sestavení $TS(k+1)$ při průchodu uzlem reprezentujícím prázdný regulární výraz}
	\label{fig:nothing}
\end{figure}
	\item \label{itm:symbol}{Posledním elementárním výrazem je symbol abecedy. Ze stavu $q_{start}$ po přečtení symbolu abecedy ze vstupní pásky, automat překopíruje tento symbol na všechny \uv{otevřené} pásky ($T[i]=1$), odstraní ho ze vstupní pásky a přejde do stavu $q_{end}$ (viz obrázek \ref{fig:symbol}). 
	Uvedené kroky lze formálně popsat takto:

        $n \gets  \mathrel{\bigg|}\{i \in \{1, \dots, k\} \mid T[i]=0\} \mathrel{\bigg|}$ 

	Pro $\forall x_1, \dots, x_{n} \in G$ a nějaký symbol abecedy $a$ se přidají přechody:
        \begin{align*}\delta(q_{start}, \langle a, \dots, \overbrace{x_1}^{T[i]=0}, &\dots, \overbrace{B}^{T[j]=1}, \dots\rangle)\leftarrow \\ &\delta(q_{start}, \langle  a, \dots, x_{1}, \dots, B, \dots\rangle) \ \cup \\ &\{(q_{end}, \langle B, 1\rangle, \dots, \langle x_1, 0\rangle, \dots, \langle a, 1\rangle \dots )\}.\end{align*}
	}
\begin{figure}[ht] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
	\centering % centers the figure
	\begin{tikzpicture}[scale=0.8]
		\tikzstyle{every node}=[scale=0.8]
		\node[state, dashed] (start) {$q_{start}$};
		\node[state, dashed, right=6cm of start] (end) {$q_{end}$};
		\draw  (start) edge node[above]{$\Big \langle a, B, 1 \Big \rangle, \dots, \overbrace{ \Big\langle x_i, x_i, 0 \Big\rangle}^{T[i]=0}, \dots, \overbrace{ \Big\langle B, a, 1 \Big\rangle}^{T[j]=1} \dots$} (end);
	\end{tikzpicture}
	\caption{Ukázka sestavení $TS(k+1)$ při průchodu uzlem reprezentujícím výraz $a$}
	\label{fig:symbol}
\end{figure}
	\end{enumerate}
 \item{Další typ vrcholu je binární operátor. Pro takovýto případ se do množiny stavů pro každý operand přidají \uv{počáteční} a \uv{koncový} stav (například stavy $q_{start}^{l}$ a $q_{end}^{l}$ pro levý operand). Algoritmus začne rekurzivně procházet pravého a levého potomka a přidávat pro ně nové stavy a přechody do automatu.}
   \begin{enumerate}
	   \item \label{itm:union}{Pokud při průchodu algoritmus narazí na uzel reprezentující sjednocení dvou výrazů, jednoduše se přidají \uv{$\varepsilon$-přechody} mezi stavem $q_{start}$ a \uv{počátečními} stavy pro potomky a z~\uv{koncových} stavů do stavu $q_{end}$  (viz obrázek \ref{fig:alter}).
	
	Pro $\forall x_0, \dots, x_{k} \in G$ se přechodová funkci modifikuje následovně:
	\begin{align*}\delta(q_{start}, \langle  x_0, \dots, x_{k}\rangle)\leftarrow&\delta(q_{start}, \langle  x_0, \dots, x_{k}\rangle) \ \cup \\ &\{(q_{start}^{l}, \langle x_0, 0\rangle, \dots, \langle x_k, 0\rangle)\}\end{align*}
	\begin{align*}\delta(q_{start}, \langle  x_0, \dots, x_{k}\rangle)\leftarrow&\delta(q_{start}, \langle  x_0, \dots, x_{k}\rangle) \ \cup\\& \{(q_{start}^{r}, \langle x_0, 0\rangle, \dots, \langle x_k, 0\rangle)\}\end{align*}
	\begin{align*}\delta(q_{end}^{l}, \langle  x_0, \dots, x_{k}\rangle)\leftarrow&\delta(q_{end}^{l}, \langle  x_0, \dots, x_k\rangle) \ \cup\\& \{(q_{end}, \langle x_0, 0\rangle, \dots, \langle x_k, 0\rangle)\}\end{align*}
	\begin{align*}\delta(q_{end}^{r}, \langle  x_0, \dots, x_{k}\rangle)\leftarrow&\delta(q_{end}^{r}, \langle  x_0, \dots, x_k\rangle) \ \cup\\&\{(q_{end}, \langle x_0, 0\rangle, \dots, \langle x_k, 0\rangle)\}\end{align*}
	}
	\begin{figure}[ht] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
	\centering % centers the figure
	\begin{tikzpicture}[scale=0.8]
		\tikzstyle{every node}=[scale=0.8]
		\node[state, dashed] (start) {$q_{start}$};
		\node[state, above right=2cm and 3.5cm of start] (sl) {$q_{start}^{l}$};
		\node[state, right=1.6cm of sl] (el) {$q_{end}^{l}$};
		\node[state, below right=2cm and 3.5cm of start] (sr) {$q_{start}^{r}$};
		\node[state, right=1.6cm of sr] (er) {$q_{end}^{r}$};
		\node[state, dashed, above right=2cm and 3.5cm of er] (end) {$q_{end}$};
		\draw  	(start) edge node[above, rotate=33]{$\Big\langle x_0, x_0, 0\Big\rangle, \dots, \overbrace{\Big\langle x_i,  x_i, 0\Big\rangle}^{T[i] \in \{0, 1\}} \dots$} (sl)
				(start) edge node[below, rotate=325]{$\Big\langle  x_0,  x_0, 0\Big\rangle, \dots, \overbrace{\Big\langle  x_i,  x_i, 0\Big\rangle}^{T[i] \in \{0, 1\}} \dots$} (sr)
				(el) edge node[above, rotate=325]{$\Big\langle  x_0,  x_0, 0\Big\rangle, \dots, \overbrace{\Big\langle  x_i,  x_i, 0\Big\rangle}^{T[i] \in \{0, 1\}} \dots$} (end)
				(er) edge node[below, rotate=33]{$\Big\langle  x_0, x_0, 0\Big\rangle, \dots, \overbrace{\Big\langle  x_i,  x_i, 0\Big\rangle}^{T[i] \in \{0, 1\}} \dots$} (end);
		\draw[dashed, fill=cyan, draw=black, opacity=0.15] (sl) circle [xshift=1.6cm, x radius=2.5cm, y radius=1.2cm] node[xshift=1.6cm, opacity=1] {$N(\alpha)$};
		\draw[dashed, fill=green, draw=black, opacity=0.15] (sr) circle [xshift=1.6cm, x radius=2.5cm, y radius=1.2cm] node[xshift=1.6cm, opacity=1] {$N(\beta)$};
	\end{tikzpicture}
	\caption{Ukázka sestavení $TS(k+1)$ při průchodu uzlem reprezentujícím výraz $\alpha+\beta$}
	\label{fig:alter}
\end{figure}
	 \item \label{itm:concat}{Další typ uzlu, na který lze při průchodu narazit, je zřetězení. Pro tento typ uzlu se do množiny stavů automatu přidá nový stav $q_{mid}$. Pak algoritmus vytvoří \uv{$\varepsilon$-přechody} mezi stavy, jako je znázorněno na obrázku \ref{fig:concat}.
	
	Pro $\forall x_0, \dots, x_{k} \in G$ se přechodová funkce upraví takto:
		\begin{align*}\delta(q_{start}, \langle  x_0, \dots, x_{k}\rangle)\leftarrow&\delta(q_{start}, \langle  x_0, \dots, x_{k}\rangle) \ \cup \\&\{(q_{start}^{l}, \langle x_0, 0\rangle, \dots, \langle x_k, 0\rangle)\}\end{align*}
		\begin{align*}\delta(q_{mid}, \langle  x_0, \dots, x_{k}\rangle)\leftarrow&\delta(q_{mid}, \langle  x_0, \dots, x_{k}\rangle) \ \cup \\&\{(q_{start}^{r}, \langle x_0, 0\rangle, \dots, \langle x_k, 0\rangle)\}\end{align*}
		\begin{align*}\delta(q_{end}^{l}, \langle  x_0, \dots, x_{k}\rangle)\leftarrow&\delta(q_{end}^{l}, \langle  x_0, \dots, x_k\rangle) \ \cup\\&\{(q_{mid}, \langle x_0, 0\rangle, \dots, \langle x_k, 0\rangle)\}\end{align*}
		\begin{align*}\delta(q_{end}^{r}, \langle  x_0, \dots, x_{k}\rangle)\leftarrow&\delta(q_{end}^{r}, \langle  x_0, \dots, x_k\rangle) \ \cup\\&\{(q_{end}, \langle x_0, 0\rangle, \dots, \langle x_k, 0\rangle)\}\end{align*}
	}

\begin{figure}[ht] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
	\centering % centers the figure
	\begin{tikzpicture}[scale=0.8]
		\tikzstyle{every node}=[scale=0.8]
		\node[state, dashed] (start) {$q_{start}$};
		\node[state, right=3.5cm of start] (sl) {$q_{start}^{l}$};
		\node[state, right=1.6cm of sl] (el) {$q_{end}^{l}$};
		\node[state, below right=2cm and 3.5cm of el] (mid) {$q_{mid}$};
		\node[state, below left=2cm and 3.5cm of mid] (sr) {$q_{start}^{r}$};
		\node[state, left=1.6cm of sr] (er) {$q_{end}^{r}$};
		\node[state, dashed, left=3.5cm of er] (end) {$q_{end}$};
		\draw  	(start) edge node[above=0.25]{$\Big\langle x_0, x_0, 0\Big\rangle, \dots, \overbrace{\Big\langle x_i, x_i, 0\Big\rangle}^{T[i] \in \{0, 1\}} \dots$} (sl)
				(mid) edge node[below, rotate=33]{$\Big\langle x_0, x_0, 0\Big\rangle, \dots, \overbrace{\Big\langle x_i, x_i, 0\Big\rangle}^{T[i] \in \{0, 1\}} \dots$} (sr)
				(el) edge node[above, rotate=325]{$\Big\langle x_0, x_0, 0\Big\rangle, \dots, \overbrace{\Big\langle x_i, x_i, 0\Big\rangle}^{T[i] \in \{0, 1\}} \dots$} (mid)
				(er) edge node[below]{$\Big\langle x_0, x_0, 0\Big\rangle, \dots, \overbrace{\Big\langle x_i, x_i, 0\Big\rangle}^{T[i] \in \{0, 1\}} \dots$} (end);
		\draw[dashed, fill=cyan, draw=black, opacity=0.15] (sl) circle [xshift=1.6cm, x radius=2.5cm, y radius=1.2cm] node[xshift=1.6cm, opacity=1] {$N(\alpha)$};
		\draw[dashed, fill=green, draw=black, opacity=0.15] (er) circle [xshift=1.6cm, x radius=2.5cm, y radius=1.2cm] node[xshift=1.6cm, opacity=1] {$N(\beta)$};
	\end{tikzpicture}
	\caption{Ukázka sestavení $TS(k+1)$ při průchodu uzlem reprezentujícím výraz $\alpha \cdot \beta$}
	\label{fig:concat}
\end{figure}
   \end{enumerate}
    \item{Při průchodu lze také narazit na unární operátor nebo definice proměnné. Potom se do množiny stavů přidají nové stavy $q_{start}^{\alpha}$ a  $q_{end}^{\alpha}$ pro potomka.}
	\begin{enumerate}
	 \item \label{itm:iter}{Jediným unárním operátorem, na nějž lze narazit při průchodu, je iterace. Pro takovýto případ algoritmus vytvoří \uv{$\varepsilon$-přechody} mezi stavy, jako je znázorněno na obrázku \ref{fig:iter}, a začne rekurzivně procházet uzlem potomka.
	
	Pro $\forall x_0, \dots, x_{k} \in G$ se přidají přechody takto:
		\begin{align*}\delta(q_{start}, \langle  x_0, \dots, x_{k}\rangle)\leftarrow&\delta(q_{start}, \langle  x_0, \dots, x_{k}\rangle) \ \cup \\&\{(q_{end}, \langle x_0, 0\rangle, \dots, \langle x_k, 0\rangle)\}\end{align*}
		\begin{align*}\delta(q_{start}, \langle  x_0, \dots, x_{k}\rangle)\leftarrow&\delta(q_{start}, \langle  x_0, \dots, x_{k}\rangle) \ \cup \\&\{(q_{start}^{\alpha}, \langle x_0, 0\rangle, \dots, \langle x_k, 0\rangle)\}\end{align*}
		\begin{align*}\delta(q_{end}^{\alpha}, \langle  x_0, \dots, x_{k}\rangle)\leftarrow&\delta(q_{end}^{\alpha}, \langle  x_0, \dots, x_k\rangle) \ \cup\\&\{(q_{start}^{\alpha}, \langle x_0, 0\rangle, \dots, \langle x_k, 0\rangle)\}\end{align*}
		\begin{align*}\delta(q_{end}^{\alpha}, \langle  x_0, \dots, x_{k}\rangle)\leftarrow&\delta(q_{end}^{\alpha}, \langle  x_0, \dots, x_k\rangle) \ \cup\\&\{(q_{end}, \langle x_0, 0\rangle, \dots, \langle x_k, 0\rangle)\}\end{align*}
	}

	\begin{figure}[ht] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
	\centering % centers the figure
	\begin{tikzpicture}[scale=0.8]
		\tikzstyle{every node}=[scale=0.8]
		\node[state, dashed] (start) {$q_{start}$};
		\node[state, above right=2cm and 3.5cm of start] (sl) {$q_{start}^{\alpha}$};
		\node[state, right=1.6cm of sl] (el) {$q_{end}^{\alpha}$};
		\node[state, dashed, below right=2cm and 3.5cm of el] (end) {$q_{end}$};
		\draw  	(start) edge node[above, rotate=33]{$\Big\langle x_0, x_0, 0\Big\rangle, \dots, \overbrace{\Big\langle x_i, x_i, 0\Big\rangle}^{T[i] \in \{0, 1\}} \dots$} (sl)
				(start) edge node[above]{$\Big\langle x_0, x_0, 0\Big\rangle, \dots, \overbrace{\Big\langle x_i, x_i, 0\Big\rangle}^{T[i] \in \{0, 1\}} \dots$} (end)
				(el) edge node[above, rotate=325]{$\Big\langle x_0, x_0, 0\Big\rangle, \dots, \overbrace{\Big\langle x_i, x_i, 0\Big\rangle}^{T[i] \in \{0, 1\}} \dots$} (end)
				(el) edge[bend right=90] node[above]{$\Big\langle x_0, x_0, 0\Big\rangle, \dots, \overbrace{\Big\langle x_i, x_i, 0\Big\rangle}^{T[i] \in \{0, 1\}} \dots$} (sl);
		\draw[dashed, fill=red, draw=black, opacity=0.15] (sl) circle [xshift=1.6cm, x radius=2.5cm, y radius=1.1cm] node[xshift=1.6cm, opacity=1] {$N(\alpha)$};
		
	\end{tikzpicture}
	\caption{Ukázka sestavení $TS(k+1)$ při průchodu uzlem reprezentujícím výraz $\alpha^\ast$}
	\label{fig:iter}
\end{figure}

	 \item \label{itm:def}{Dalším typem uzlu je definice proměnné. Jelikož pro libovolnou proměnnou $y$ je vyhrazena právě jedna $num(y)$-tá páska a definice proměnné se může opakovat ve výrazů několikrát, je nutné nejprve všechny neprázdné symboly z~pásky vymazat. Stroj postupně posouvá čtecí hlavu na příslušné pásce a maže symboly, dokud nenarazí na první \emph{blank} symbol (viz obrázek \ref{fig:def}). Pak algoritmus \uv{povolí} zápis na pásku a rekurzivně projde uzlem potomka. Po skončení se \uv{zakáže} zápis na pásku a automat přejde do koncového stavu $q_{end}$. 

	Pro  $\forall x_0, \dots, x_{k-1} \in G$ se přechodová funkce modifikuje následovně:
		\begin{equation*}\begin{split}
		\delta(q_{start}, \langle  x_0, \dots, \overbrace{B}^{num(y)}, \dots \rangle)\leftarrow&\delta(q_{start}, \langle  x_0, \dots, B, \dots \rangle) \ \cup\\&\{(p, \langle x_0, 0\rangle, \dots, \langle B, -1\rangle, \dots)\}\end{split}\end{equation*}
		\begin{equation*}\begin{split}
		\delta(p, \langle  x_0, \dots, \overbrace{B}^{num(y)}, \dots \rangle)\leftarrow&\delta(p, \langle  x_0, \dots, B, \dots \rangle) \ \cup\\&\{(q_{start}^{\alpha}, \langle x_0, 0\rangle, \dots, \langle B, 1\rangle, \dots)\}\end{split}\end{equation*}
	Pro $\forall x_0, \dots, x_{k-1} \in G$,  $\forall z~\in \Sigma$ algoritmus vytvoří přechody takto:
\begin{equation*}\begin{split}\delta(p, \langle  x_0, \dots, \overbrace{z}^{num(y)}, \dots \rangle)\leftarrow&\delta(p, \langle  x_0, \dots, z, \dots \rangle) \ \cup\\&\{(p, \langle x_0, 0\rangle, \dots, \langle B, -1\rangle, \dots)\}\end{split}\end{equation*}
		Pro $\forall x_0, \dots, x_{k} \in G$:
		\begin{equation*}\begin{split}\delta(q_{end}^{\alpha}, \langle  x_0, \dots, x_{k}\rangle)\leftarrow&\delta(q_{end}^{\alpha}, \langle  x_0, \dots, x_k\rangle) \ \cup \\ &\{(q_{end}, \langle x_0, 0\rangle, \dots, \langle x_k, 0\rangle)\} \end{split}\end{equation*}
	}
	
\begin{figure}[ht] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
	\centering % centers the figure
	\begin{tikzpicture}[scale=0.8]
		\tikzstyle{every node}=[scale=0.8]
		\node[state, dashed] (start) {$q_{start}$};
		\node[state, above right=2cm and 3.5cm of start] (p) {$p$};
		\node[state, right= 4.5cm of p] (sl) {$q_{start}^{\alpha}$};
		\node[state, below=1.6cm of sl] (el) {$q_{end}^{\alpha}$};
		\node[state, dashed, left=4.5cm of el] (end) {$q_{end}$};
		\node[draw, above=0.5cm of sl] (t1) {$T[num(y)] \leftarrow 1$};
		\node[draw, below=0.5cm of el] (t2) {$T[num(y)] \leftarrow 0$};
		\draw  	(start) edge node[above=0.25cm, rotate=33]{$\Big\langle x_0, x_0, 0\Big\rangle, \dots, \overbrace{\Big\langle B, B, -1\Big\rangle}^{num(y)} \dots$} (p)
				(p) edge[loop above] node{$\Big\langle x_0, x_0, 0\Big\rangle, \dots, \overbrace{\Big\langle z, B, -1\Big\rangle}^{num(y)} \dots$} (p)
				(p) edge node[above]{$\Big\langle x_0, x_0, 0\Big\rangle, \dots, \overbrace{\Big\langle B, B, 1\Big\rangle}^{num(y)}\dots$} (sl)
				(el) edge node[above]{$\Big\langle x_0, x_0, 0\Big\rangle, \dots, \overbrace{\Big\langle x_i, x_i, 0\Big\rangle}^{T[i] \in \{0, 1\}} \dots$} (end);
		\draw[dashed, fill=red, draw=black, opacity=0.15] (el) circle [yshift=1.6cm, x radius=1.1cm, y radius=2.5cm] node[yshift=1.6cm, opacity=1] {$N(\alpha)$};
		
	\end{tikzpicture}
	\caption{Ukázka sestavení $TS(k+1)$ při průchodu uzlem reprezentujícím definici proměnné $y\{\alpha\}$}
	\label{fig:def}
\end{figure}

	\end{enumerate}
	\item \label{itm:ref}{Poslední typ uzlu, na který lze narazit při průchodu, je zpětná reference. Podobně jako v~předchozím případě stroj postupně posouvá čtecí hlavu na příslušné pásce, dokud nenarazí na první \emph{blank} symbol (viz obrázek~\ref{fig:ref}). Pak začne porovnávat obsah vstupní pásky s~$num(y)$-tou a přejde do koncového stavu pouze v~případě, že se obsahy obou pásek shodují.

	Pro  $\forall x_0, \dots, x_{k-1} \in G$ se přidají následující přechody:
		\begin{equation*}\begin{split}\delta(q_{start}, \langle  x_0, \dots, \overbrace{B}^{num(y)}, \dots \rangle)\leftarrow&\delta(q_{start}, \langle  x_0, \dots, B, \dots \rangle) \ \cup\\&\{(p, \langle x_0, 0\rangle, \dots, \langle B, -1\rangle, \dots)\}\end{split}\end{equation*}
		\begin{equation*}\begin{split}\delta(p, \langle  x_0, \dots, \overbrace{B}^{num(y)}, \dots \rangle)\leftarrow&\delta(p, \langle  x_0, \dots, B, \dots \rangle) \ \cup\\&\{(q, \langle x_0, 0\rangle, \dots, \langle B, 1\rangle, \dots)\}\end{split}\end{equation*}
		\begin{equation*}\begin{split}\delta(q, \langle  x_0, \dots, \overbrace{B}^{num(y)}, \dots \rangle)\leftarrow&\delta(q, \langle  x_0, \dots, B, \dots \rangle) \ \cup\\&\{(q_{end}, \langle x_0, 0\rangle, \dots, \langle B, 0\rangle, \dots)\}\end{split}\end{equation*}
	Pro $\forall x_0, \dots, x_{k-1} \in G$,  $\forall z~\in \Sigma$ se přechodová funkce modifikuje následovně:
	\begin{flalign*}\delta(p, \langle  x_0, \dots, \overbrace{z}^{num(y)}, \dots \rangle)\leftarrow&\delta(p, \langle  x_0, \dots, z, \dots \rangle) \ \cup\\&\{(p, \langle x_0, 0\rangle, \dots, \langle z, -1\rangle, \dots)\}\end{flalign*}
		Pro $\forall x_0, \dots, x_{k-2} \in G$,  $\forall z~\in \Sigma$:
	\begin{flalign*}\delta(q, \langle  z, \dots, \overbrace{z}^{num(y)}, \dots \rangle)\leftarrow&\delta(q, \langle  z, \dots, z, \dots \rangle) \ \cup\\&\{(q, \langle B, 1\rangle, \dots, \langle z, 1\rangle, \dots)\}\end{flalign*}
	}

\begin{figure}[ht] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
	\centering % centers the figure
	\begin{tikzpicture}[scale=0.8]
			\tikzstyle{every node}=[scale=0.8]
		\node[state, dashed] (start) {$q_{start}$};
		\node[state, above right=2cm and 3.5cm of start] (p) {$p$};
		\node[state, right= 4.5cm of p] (q) {$q$};
		\node[state, dashed, below left=2cm and 3.5cm of q] (end) {$q_{end}$};
		\draw (start) edge node[above=0.25cm, rotate=33]{$\Big\langle x_0, x_0, 0\Big\rangle, \dots, \overbrace{\Big\langle B, B, -1\Big\rangle}^{num(y)} \dots$} (p)
				(p) edge[loop above] node{$\Big\langle x_0, x_0, 0\Big\rangle, \dots, \overbrace{\Big\langle z, z, -1\Big\rangle}^{num(y)} \dots$} (p)
				(p) edge node[above]{$\Big\langle x_0, x_0, 0\Big\rangle, \dots, \overbrace{\Big\langle B, B, 1\Big\rangle}^{num(y)}\dots$} (q)
				(q) edge[loop above] node[above=0.25cm]{$\Big\langle z, B, 1\Big\rangle, \dots, \overbrace{\Big\langle z, z, 1\Big\rangle}^{num(y)} \dots$} (q)
				(q) edge node[below, rotate=32]{$\Big\langle x_0, x_0, 0\Big\rangle, \dots, \overbrace{\Big\langle B, B, 0\Big\rangle}^{num(y)} \dots$} (end);
		
	\end{tikzpicture}
	\caption{Ukázka sestavení $TS(k+1)$ při průchodu uzlem reprezentujícím zpětnou referenci na proměnnou $y$}
	\label{fig:ref}
\end{figure}
	
\end{enumerate}

\begin{theorem}
	Časová složitost algoritmu \ref{alg:turing} je $\mathcal{O}(|\alpha| \cdot |\Sigma|^{k+1} )$.
\end{theorem}
\begin{proof} Inicializace algoritmu (kroky 1 až 3) trvá $\mathcal{O}(k)$. Algoritmus rekurzivně prochází každý vrchol syntaktického stromu nejvýše jednou, tedy se celkem provede $\mathcal{O}(|\alpha|)$ volání funkce \texttt{build-TM}. v~každém volání se do množiny stavů přidají maximálně $5$ stavů (krok 15) a vytvoří se nejvýše $2|G|^k + |G|^{k+1} + |\Sigma|\cdot|G|^k \le 3|G|^{k+1}$ přechodů (krok 24). Jelikož $|G|=|\Sigma|+1$, jedno volání funkce potrvá $\mathcal{O}(|\Sigma|^{k+1})$. Celkově tedy algoritmus spotřebuje čas $\mathcal{O}(|\alpha| \cdot |\Sigma|^{k+1} )$.
\end{proof}

\begin{theorem}\label{theorem:correct1}
Pro regex $\alpha$ výstupem algoritmu \ref{alg:turing} je lineárně omezený TS s~$k$~páskami $\mathcal{M}$ takový, že $L(\mathcal{M}) = L(\alpha)$.
\end{theorem}
\begin{proof} Buď $\mathcal{M}$ výstupní Turingův stroj, buď $\varphi$ kořen AST pro $\alpha$. Ekvivalenci tohoto výpočetního modelu a regexu lze dokázat indukcí podle typu uzlu $\varphi$.
\begin{enumerate}
	\item{Pro elementární výraz je tvrzení triviální.
		\subitem{Nechť je $\varphi$ uzel reprezentující regex $\varepsilon$. $L(\varepsilon)=\{\varepsilon\}$. Výstupem algoritmu pro $\varphi$ je $\mathcal{M}=(\{q_{start}, q_{end}\},  \varnothing, \{B\}, \delta, q_{start}, B, \{q_{end}\} )$. Jazyk přijímaný $\mathcal{M}$ je $\{ w \mid \left(q_{start}, \left( BwB \right),  \left(1\right)\right) \vdash_{\mathcal{M}} \left(q_{end}, \left(B^{|w|+2} \right),  \left(1 \right)\right) \} = \{\varepsilon\}$. 
		}
		\subitem{Nechť $\varphi$ reprezentuje prázdný regulární výraz. $L(\varnothing)=\varnothing$. Výstupem je $\mathcal{M}=(\{q_{start}, p,  q_{end}\}, \varnothing, \{B\}, \delta, q_{start}, B, \{q_{end}\} )$. Jelikož v~přechodové funkci automatu neexistuje žádný přechod do koncového stavu, $L(\mathcal{M})=\varnothing$. 
		}
		\subitem{Poslední elementární výraz, na něhož může algoritmus při průchodu narazit, je symbol abecedy $a$. $L(a)=a$. Výstupem algoritmu pro $\varphi$ je  $\mathcal{M}=(\{q_{start}, q_{end}\}, \{a\}, \{B, a\}, \delta, q_{start}, B, \{q_{end}\} )$.  Jazyk přijímaný $\mathcal{M}$ je $\{ w \mid \left(q_{start}, \left( BwB \right),  \left(1\right)\right) \vdash_{\mathcal{M}} \left(q_{end}, \left(B^{|w|+2} \right),  \left(2 \right)\right) \} = \{a\}$. 
		}
	}
	\item{Nechť $\varphi$ reprezentuje regulární operaci. 
		\subitem{ Kořen $\varphi$ reprezentuje regex $\beta \cdot \gamma$. Hodnota výrazu je $L(\beta \cdot \gamma) = L(\beta)L(\gamma)$. Nechť $\mathcal{M}_{\beta}$ a $\mathcal{M}_{\gamma}$ jsou automaty pro $\beta$ a $\gamma$. Výstupní TS $\mathcal{M}$ přijímá jazyk $L(\mathcal{M}_{\beta})L(\mathcal{M}_{\gamma})= L(\beta)L(\gamma)$.
		}
		\subitem{ Nechť $\varphi$ reprezentuje regex $\beta + \gamma$. $L(\beta + \gamma) = L(\beta)\cup L(\alpha)$. Nechť $\mathcal{M}_{\beta}$ a $\mathcal{M}_{\gamma}$ jsou automaty pro $\beta$ a $\gamma$. Výstupní TS $\mathcal{M}$ přijímá jazyk $L(\mathcal{M}_{\beta})\cup L(\mathcal{M}_{\gamma})= L(\beta)\cup L(\gamma)$.
		}
		\subitem{Nechť je $\varphi$ uzel reprezentující regex $\beta^\ast$. Hodnota výrazu je $L(\beta^\ast) = L(\beta)^\ast$. Buď $\mathcal{M}_{\beta}$ automat pro regex $\beta$. Jazyk přijímaný výstupním TS $\mathcal{M}$ je $\{\varepsilon\}\cup L(\mathcal{M}_{\beta})\cup L(\mathcal{M}_{\beta}) L(\mathcal{M}_{\beta})\cup\dots = L(\mathcal{M}_{\beta})^\ast= L(\beta)^\ast$.
		}
	}
	\item{Nechť $\varphi$ reprezentuje definici proměnné $x\{\beta\}$. $L(x\{\beta\})= L(\beta)$. Buď $\mathcal{M}_{\beta} = (Q, \Sigma, G, \delta_{\mathcal{M}_{\beta}}, start_{\mathcal{M}_{\beta}}, B, F)$ automat pro regex $\beta$. Výstupní automat $\mathcal{M}$ je sedmice $(\{q_{start}, p, q_{end}\}\cup Q, \Sigma, G, \delta_{\mathcal{M}}, q_{start}, B, \{q_{end}\})$. Jazyk přijímaný automatem $\mathcal{M}$ je $\{ w \mid \left(q_{start}, \left( BwB, B^{|w|+2}\right),  \left(1, 1\right)\right) \vdash_{\mathcal{M}}^\ast \left(q_{end}, \left(B^{|w|+2}, BwB \right),  \left(|w|+1, |w|+1 \right)\right) \} = L(\mathcal{M}_{\beta})= L(\beta)$. Na konci výpočtu na pracovní pásce pro proměnnou $x$ je zapsáno vstupní slovo $w$. 
	}
	\item{Nechť $\varphi$ reprezentuje zpětnou referenci na $x$. Výstupní automat $\mathcal{M}$ je sedmice $(\{q_{start}, p, q, q_{end}\}, \Sigma, G, \delta_{\mathcal{M}}, q_{start}, B, \{q_{end}\})$. Jazyk přijímaný $\mathcal{M}$ je \begin{flalign*}\{ w \mid &\left(q_{start}, \left( BwB, BwB\right),  \left(1, 1\right)\right) \vdash_{\mathcal{M}}^\ast \\&\left(q_{end}, \left(B^{|w|+2}, BwB \right),  (|w|+1, |w|+1)\right) \}.\end{flalign*} Automat přijme pouze slova, která odpovídají obsahu pracovní pásky pro proměnnou $x$. Pokud je páska prázdná, proměnná nebyla ve výrazu definována. Potom $L(\mathcal{M})$ se rovná hodnotě $L(x)$.}
\end{enumerate}
Jelikož automat $\mathcal{M}$ použije maximálně $|w|+2$ buněk na každé pásce (celkem $(k+1)(|w|+2)$ pro $k=|var(\alpha)|$), výstupní TS je lineárně omezený. 
\end{proof}

Jelikož pro každý regex lze sestrojit ekvivalentní vícepáskový Turingův stroj pomocí algoritmu \ref{alg:turing} a pro každý $k$-páskový TS existuje ekvivalentní jednopáskový TS (věta \ref{thm:multitape}), platí následující tvrzení.

\begin{theorem}
Každý jazyk z~množiny $\mathbb{L}_{REGEX} $ je kontextovým jazykem.
\end{theorem} 

Algoritmus, který přijme na vstup regex $\alpha$ a vstupní slovo $w$, zkonstruuje ekvivalentní vícepáskový TS $\mathcal{M}$ a nasimuluje výpočet $\mathcal{M}$ pro vstup $w$, se v~této práci nazývá \texttt{simpleTM}.

Příklad převodu regexu na vícepáskový TS lze najít v~příloze \ref{ukazka:simpletm}.

Lze však ukázat, že se výpočet vícepáskového Turingova stroje, který byl zkonstruován pomocí algoritmu \texttt{simpleTM}, může zacyklit (i když ve vstupním regexu není žádná proměnná). Tento případ je potřeba ošetřit.
\begin{example}\label{ex:cycle}
Buď $\alpha = (a+\varepsilon)^\ast a$. Výstupem algoritmu pro tento regex je TS~$\mathcal{M}$ s~jednou páskou a přechodovou funkcí $\delta$ (viz obrázek \ref{fig:infiniteloop}).

\begin{figure}[ht] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
	\centering % centers the figure
	\begin{tikzpicture}[scale=0.6]
	\tikzstyle{every node}=[scale=0.6]
		\node[initial, state] (init) {$q_s$};
		\node[state, below=1.5cm of init] (start) {$q_0$};
		\node[state, right=9cm of start] (q7) {$q_7$};
		\node[state, above=1.4cm of q7] (q8) {$q_8$};
		\node[state, above=1.4cm of q8] (q9) {$q_9$};
		\node[state, left=1.5cm of q9] (q10) {$q_{10}$};
		\node[accepting, state, above left=0.3cm and 1.5cm of q10] (end) {$q_{e}$};
		\node[state, above right=1cm and 1cm of start] (q1) {$q_1$};
		\node[state, above right=0.2cm and 2cm of q1] (q2) {$q_2$};
		\node[state, right=1cm of q2] (q3) {$q_3$};
		\node[state, below right=0.2cm and 2cm of q1] (q4) {$q_4$};
		\node[state, right=1cm of q4] (q5) {$q_5$};
		\node[state, below right= 0.2cm and 2cm of q3] (q6) {$q_6$};
		
		\draw 	(init) edge[bend right] node[above left = 3mm and 0mm]{$\big\langle a, a, 0 \big\rangle$} node[above left]{$\big\langle B, B, 0 \big\rangle$} (start)
				(start) edge node[below]{$\big\langle a, a, 0 \big\rangle$} node[below=4mm]{$\big\langle B, B, 0 \big\rangle$}  (q7)
				(start) edge node[above left]{$\big\langle a, a, 0 \big\rangle$} node[above left =4mm and 0mm]{$\big\langle B, B, 0 \big\rangle$} (q1)
				(q6) edge node[right]{$\big\langle a, a, 0 \big\rangle$} node[above right]{$\big\langle B, B, 0 \big\rangle$} (q7)
				(q1) edge node[above]{$\big\langle a, a, 0 \big\rangle$} node[above=4mm]{$\big\langle B, B, 0 \big\rangle$} (q2)
				(q1) edge node[below left]{$\big\langle a, a, 0 \big\rangle$} node[below left=4mm and 0mm]{$\big\langle B, B, 0 \big\rangle$} (q4)
				(q2) edge node[above]{$\big\langle a, B, 1 \big\rangle$} (q3)
				(q4) edge node[above]{$\big\langle a, a, 0 \big\rangle$} node[above=4mm]{$\big\langle B, B, 0 \big\rangle$} (q5)
				(q3) edge node[above]{$\big\langle a, a, 0 \big\rangle$} node[above=4mm]{$\big\langle B, B, 0 \big\rangle$} (q6)
				(q5) edge node[below right]{$\big\langle a, a, 0 \big\rangle$} node[below right=4mm and 0mm]{$\big\langle B, B, 0 \big\rangle$} (q6)
				(q6) edge[bend right = 70] node[above]{$\big\langle a, a, 0 \big\rangle$} node[above=4mm]{$\big\langle B, B, 0 \big\rangle$} (q1)
				(q7) edge[bend right] node[above right]{$\big\langle a, a, 0 \big\rangle$} node[right]{$\big\langle B, B, 0 \big\rangle$} (q8)
				(q9) edge node[above]{$\big\langle a, B, 1 \big\rangle$} (q10)
				(q8) edge node[left]{$\big\langle a, a, 0 \big\rangle$} node[above left]{$\big\langle B, B, 0 \big\rangle$} (q9)
				(q10) edge node[above right]{$\big\langle a, a, 0 \big\rangle$} node[above right = 3mm and 0mm ]{$\big\langle B, B, 0 \big\rangle$} (end);
		
	\end{tikzpicture}
	\caption{Přechodová funkce TS přijímajícího jazyk $L((a+\varepsilon)^\ast a)$}
	\label{fig:infiniteloop}
\end{figure}
Automat se zacyklí například pro vstup $w=\varepsilon$. Posloupnost přechodů $\mathcal{M}$ z~počáteční konfigurace $(q_s, \big\langle BB\big\rangle, \big\langle1\big\rangle)$ je zobrazena na obrázku \ref{fig:exloop}.
\begin{figure}[h]
\centering

\begin{tikzpicture}[scale=0.6, edge from parent path={(\tikzparentnode.south) .. controls +(0,-0.4) and +(0,0.4).. (\tikzchildnode.north)}, |-]
	\tikzstyle{every node}=[scale=0.6, fill=gray!30,rounded corners]
	\tikzstyle{level 1}=[sibling distance=5cm]\tikzstyle{level 2}=[sibling distance=6cm]\tikzstyle{level 3}=[sibling distance=4cm]
	\node {$(q_s, \big\langle BB\big\rangle, \big\langle1\big\rangle)$}
		[level distance=1cm]
		child {node {$(q_0, \big\langle BB\big\rangle, \big\langle1\big\rangle)$}
			child {node {$(q_7, \big\langle BB\big\rangle, \big\langle1\big\rangle)$}
				child {node {$(q_8, \big\langle BB\big\rangle, \big\langle1\big\rangle)$}
					child {node {$(q_9, \big\langle BB\big\rangle, \big\langle1\big\rangle)$ -- \texttt{false}}}
				}
			}
			child {node (b) {$(q_1,\big\langle BB\big\rangle, \big\langle1\big\rangle)$}
				child {node {$(q_2, \big\langle BB\big\rangle, \big\langle1\big\rangle)$ -- \texttt{false}}}
				child {node {$(q_4, \big\langle BB\big\rangle, \big\langle1\big\rangle)$}
					child {node {$(q_5, \big\langle BB\big\rangle, \big\langle1\big\rangle)$}
						child {node (a) {$(q_6, \big\langle BB\big\rangle, \big\langle1\big\rangle)$}
							child {node {$(q_7, \big\langle BB\big\rangle, \big\langle1\big\rangle)$}
								child {node {$(q_8, \big\langle BB\big\rangle, \big\langle1\big\rangle)$}
									child {node {$(q_9, \big\langle BB\big\rangle, \big\langle1\big\rangle)$ -- \texttt{false}}}
								}
							}
						}
					}
				}
			}
		};
	\draw[red] (a) -- (6.8, -5) -- (6.8,-2) -- (b);
\end{tikzpicture}
\caption{Posloupnost přechodů $\mathcal{M}$ pro $w=\varepsilon$}\label{fig:exloop}
\end{figure}
Lze si všimnout, že tato situace nastává, když v~AST existuje vrchol reprezentující iteraci a hodnota výrazu potomka daného vrcholu obsahuje prázdné slovo~$\varepsilon$. Potom se při výpočtu může vzniknout cyklus v~posloupnosti přechodů $$(q_{start}^\alpha, \big\langle w_0, \dots\big\rangle, \big\langle i_0, \dots\big\rangle) \vdash_{\mathcal{M}}^\ast (q_{start}^\alpha, \big\langle w_0, \dots\big\rangle, \big\langle i_0, \dots\big\rangle),$$ kde $q_{start}^\alpha$ je počáteční stav pro potomka (viz obrázek~\ref{fig:iter}). 
\end{example}

Je však možné upravit algoritmus \ref{alg:tmsim} pro simulaci vícepáskového TS tak, aby podobné situace nevznikaly. Nejprve pro každý takový stav $q_{start}^\alpha$ uložíme konfiguraci pásek pokaždé, když algoritmus zavolá funkci \texttt{accepts} se vstupním parametrem $curState = q_{start}^\alpha$. Pokud se nová konfigurace rovná uložené, algoritmus tuto větev zahodí a funkce vrátí \texttt{false}. Pomocí kontroly opakování konfigurací je docíleno toho, aby se při simulaci konfigurace neopakovaly.  
\begin{pozorovani}\label{poz:out}Výstup algoritmu \ref{alg:turing} je $TS(k)$ $\mathcal{M}$, který má následující vlastnost. Pro libovolnou konfiguraci $\varphi = \left(q, \langle w_1, \dots, w_k\rangle,  \langle i_1, \dots, i_k\rangle\right)$ platí $$|\{p  \mid \varphi \vdash_\mathcal{M} p\}|\le2.$$
\end{pozorovani}
\begin{theorem}Algoritmus \texttt{simpleTM} pracuje v~čase $\mathcal{O}(|\alpha|\cdot|\Sigma|^{k+1}\cdot|w|^{4k})$, kde $k = |var(\alpha)|$. \end{theorem}
\begin{proof}
Množina všech konfigurací vícepáskového TS $\mathcal{M}$, který je výstupem algoritmu \ref{alg:turing}, je $C_{\mathcal{M}}= \{\left(q, \langle w_0, w_1, \dots, w_k\rangle,  \langle i_0, i_1, \dots, i_k\rangle\right) \mid w_0 \in S_w, \forall i \in \{1, \dots, k\} \ w_i \in F_w\}$ (kde $S_w$ (resp. $F_w$) je množina suffixů (resp. podřetězců) $w$). Pro počet konfigurací stroje platí $|C_{\mathcal{M}}| = \mathcal{O}(|Q|\cdot|w|^k \cdot (|w|^2)^k \cdot |w|^{k} ) = \mathcal{O}(|Q|\cdot|w|^{4k})$ (kde $Q$ je množina stavů $\mathcal{M}$).
Z pozorování \ref{poz:out} vyplývá, že simulace $\mathcal{M}$ spotřebuje čas $\mathcal{O}(|Q|\cdot|w|^{4k})$. Jelikož platí $Q=\mathcal{O}(|\alpha|)$ (pro každý vrchol AST se vytvoří maximálně 5 stavů) a konstrukce $TS(k)$ spotřebuje čas $\mathcal{O}(|\alpha|\cdot|\Sigma|^{k+1})$, celkem zpracování regexu $\alpha$ trvá $\mathcal{O}(|\alpha|\cdot|\Sigma|^{k+1}\cdot|w|^{4k})$.
\end{proof}

\section{Memory automat}\label{sec:memory}
V této sekci je popsán další výpočetní model přijímající \textsc{Regex} jazyky. \emph{Memory automat} (zkráceně $\mu KA(k)$) lze chápat jako nedeterministický konečný automat rozšířený o $k$ adresovatelných paměti. Při definování pojmů týkajících se memory automatů je vycházeno z~\cite[sekce 2.2]{schmidref}.

\begin{definition}
Buď $k \in \mathbb{N}_0$ a buď $\Gamma = \{i, [\,_i, ]\,_i \mid i \in \{0,\dots, k-1\}\}$.
$\mu KA(k)$ je formálně definován jako pětice $\mathcal{M} = \left(Q, \Sigma, \delta, q_0, F\right)$, kde:
\begin{itemize}
	\item{$Q$ je konečná neprázdná množina vnitřních stavů,}
	\item{$\Sigma$ je neprázdná vstupní abeceda,}
	\item{$\delta$ : $\left(Q \times (\Sigma \cup \{\varepsilon\} \cup \Gamma)\right) \rightarrow \wp\left( Q \right)$ je přechodová funkce,}
	\item{$q_0 \in Q$ je počáteční stav,}
	\item{$F \subseteq Q$ je množina koncových stavů. \cite{schmidref}}
\end{itemize}
\end{definition}

\begin{definition}
Konfigurace $\mu KA(k)$ je trojice ${(q, w, (\big\langle r_0, s_0\big\rangle, \dots \big\langle r_{k-1}, s_{k-1}\big\rangle))}$, kde:
\begin{itemize}
	\item $q$ je aktuální stav,
	\item $w$ je obsah vstupní pásky,
	\item $r_i$ je obsah $i$-té paměti,
	\item $s_i \in \{\texttt{O}, \texttt{C}\}$ je stav $i$-té paměti. \cite{schmidref}
\end{itemize}
\end{definition}

Sémantický význam jednotlivých přechodů je zaveden pomocí následující definice.

\begin{definition}
	Buď $c_i, c_j$ jsou konfigurace automatu. Binární relace $\vdash_{\mathcal{M}}$ na množině konfigurací automatů je definovaná následovně:
	
	$c_i \vdash_{\mathcal{M}} c_j$, právě když platí alespoň jedno z~následujících tvrzení:
	\begin{itemize}
		\item $c_i=(q, vw,  (\big\langle r_0, s_0\big\rangle, \dots, \big\langle r_{k-1}, s_{k-1}\big\rangle))$;

			 $c_j = (p, w,  (\big\langle r_0^\prime, s_0\big\rangle, \dots, \big\langle r_{k-1}^\prime, s_{k-1}\big\rangle))$;

			 $\exists p \in \delta(q, x)$, kde $(x \in \Sigma \cup \{\varepsilon\} \ \wedge \ v~= x)$ nebo $(x \in \{0,\dots, k-1\} \ \wedge{s_x = \texttt{C} \ \wedge \ v~= r_{x} })$ a platí

			\subitem$\forall i \in \{0, \dots, k-1\} \bigg( s_i = \texttt{O} \implies r_i^\prime = r_i v\bigg)$,

			\subitem $\forall i \in \{0, \dots, k-1\} \bigg( s_i = \texttt{C} \implies r_i^\prime = r_i\bigg)$.
		\item  $c_i=(q, vw,  (\big\langle r_0, s_0\big\rangle, \dots, \big\langle r_{k-1}, s_{k-1}\big\rangle))$;

			 $c_j = (p, w,  (\big\langle r_0^\prime, s_0\big\rangle,  \dots , \big\langle r_{j}^\prime, s_{j}\big\rangle, \dots ,\big\langle r_{k-1}^\prime, s_{k-1}\big\rangle))$;
			
			 $\exists p \in \delta(q, x)$, kde $(x = [\,_j \ \wedge \ s_j^\prime = \texttt{O} \ \wedge \ r_j^\prime = \varepsilon)$ nebo $(x = \ ]\,_j \ \wedge \  {s_j^\prime = \texttt{C} \ \wedge}  {r_j^\prime = r_j})$. \cite{schmidref}
			
			
	\end{itemize}
\end{definition}

Počáteční konfigurace $\mu KA(k)$ $\mathcal{M}$ pro vstup $w$ je konfigurace $$\left(q_0, w, (\langle \varepsilon, \texttt{C} \rangle \dots \langle\varepsilon, \texttt{C}\rangle)\right).$$ Konfigurace ${\left(p, \varepsilon, (\langle r_0, s_0 \rangle, \dots, \langle r_{k-1}, s_{k-1}\rangle)\right)}$ je \emph{koncová}, právě když p je koncový stav. Memory automat {přijímá slovo $w$}, pokud existuje posloupnost konfigurací z~počáteční (pro tento vstup) do nějaké koncové.

\emph{Jazyk přijímaný $\mu KA(k)$ $\mathcal{M}$} je množina všech slov, které daný automat přijímá.

Podobně jako je tomu u vícepáskového TS, simulace výpočtu memory automatu pro vstupní slovo $w$ odpovídá prohledávání grafů konfigurací tohoto automatu. 

\section{Převod regexu na ekvivalentní memory automat}\label{section:simplemem}
Tato sekce je věnována algoritmu pro převod regexu na memory automat. Postup konstrukce byl převzat z~\cite[sekce 2.3]{schmidref}.

Prvním krokem je konstrukce orientovaného grafu s~ohodnocenými hranami $\mathcal{H}(\alpha)$ pro vstupní regex $\alpha$, která je popsána pomocí následující definice.     

\begin{definition}Buď $\alpha \in RV_{\Sigma, X}$, a buď $\mathcal{N}(\alpha)$ množina uzlů syntaktického stromu, který reprezentuje $\alpha$.
Orientovaný graf s~ohodnocenými hranami $\mathcal{H}(\alpha)$ je trojice $(V, E, f)$, kde $V$ je množina vrcholů, $E$ je množina hran a $f$ je zobrazení z~$E$ do $\Sigma\cup X \cup \Gamma \cup \{\varepsilon\}$ ($\Gamma = \{ [\,_x, ]\,_x \mid x \in X \}$). Pro každý uzel $t$ z~$\mathcal{N}(\alpha)$ v~množině vrcholu $V$ jsou dva vrcholy $t_{in}, t_{out}$ (pro zřetězení $V$ obsahuje navíc vrchol $t_{mid}$). 
	\begin{itemize}
		\item{Pokud uzel $t$ reprezentuje zřetězení, množina hran obsahuje hrany $e_1 = (t_{in}, l_{in})$, $e_2=(l_{out}, t_{mid})$, $e_3=(t_{mid}, r_{in})$ a $e_4=(r_{out}, t_{out})$, kde $l$ (resp. $r$) je uzel reprezentující levého (resp. pravého) potomka. Hrany $e_1, e_2, e_3, e_4$ jsou ohodnoceny $\varepsilon$.}
		\item{Pokud uzel $t$ reprezentuje sjednocení, množina hran obsahuje hrany $e_1 = (t_{in}, l_{in})$, $e_2=(t_{in}, r_{in})$, $e_3=(l_{out}, t_{out})$ a $e_4=(r_{out}, t_{out})$. Hrany $e_1, e_2, e_3, e_4$ jsou ohodnoceny $\varepsilon$.}
		\item{Pokud uzel $t$ reprezentuje iteraci, množina hran obsahuje hrany $e_1 = (t_{in}, i_{in})$, $e_2=(t_{in}, t_{out})$, $e_3=(t_{out}, t_{in})$ a $e_4=(i_{out}, t_{out})$, kde $i$ je uzel reprezentující potomka. Hrany $e_1, e_2, e_3, e_4$ jsou ohodnoceny $\varepsilon$.}
		\item{Pokud uzel $t$ reprezentuje iteraci, množina hran obsahuje hrany $e_1 = (t_{in}, i_{in})$, $e_2=(t_{in}, t_{out})$, $e_3=(t_{out}, t_{in})$ a $e_4=(i_{out}, t_{out})$, kde $i$ je uzel reprezentující potomka. Hrany $e_1, e_2, e_3, e_4$ jsou ohodnoceny $\varepsilon$.}
		\item{Pokud uzel $t$ reprezentuje elementární výraz, množina hran obsahuje hranu $e = (t_{in}, t_{out})$ a hrana je ohodnocena hodnotou tohoto výrazu.}
		\item{Pokud uzel $t$ reprezentuje definici na proměnnou $x$, množina hran obsahuje hrany $e_1 = (t_{in}, i_{in})$, $e_2=(i_{out}, t_{out})$, kde $i$ je uzel reprezentující potomka. $f(e_1)=[\,_x$ a $f(e_2)= \ ]\,_x$.}
		\item{Pokud uzel $t$ reprezentuje zpětnou referenci na $x \in X$, množina hran obsahuje hranu $e = (t_{in}, t_{out})$ ($f(e)=x$). \cite{schmidref}}
	\end{itemize}
\end{definition}

\begin{figure}[h]
\centering

\begin{tikzpicture}
	\tikzstyle{vertex}=[fill=gray!15,rounded corners, minimum height=1cm, minimum width=1cm]	
	\node[vertex] (con1) {$\cdot$};
	\node[vertex, below left=1cm and 0.75cm of con1] (defx) {$x\{\}$};
	\node[vertex, below=1cm of defx] (union) {$+$};
	\node[vertex, below left=1cm and 0.25cm of union] (ita) {$\ast$};
	\node[vertex, below right=1cm and 0.25cm of union] (itb) {$\ast$};
	\node[vertex, below=1cm of ita] (a1) {$a$};
	\node[vertex, below=1cm of itb] (b1) {$b$};
	\node[vertex, below right=1cm and 0.75cm of con1] (con2) {$\cdot$};
	\node[vertex, below left=1cm and 0.5cm of con2] (x) {$x$};
	\node[vertex, below right=1cm and 0.5cm of con2] (it) {$\ast$};
	\node[vertex, below=1cm of it] (con3) {$\cdot$};
	\node[vertex, below left=1cm and 0.25cm of con3] (y) {$y$};
	\node[vertex, below right=1cm and 0.25cm of con3] (con4) {$\cdot$};
	\node[vertex, below left=1cm and 0.25cm of con4] (b2) {$b$};
	\node[vertex, below right=1cm and 0.25cm of con4] (defy) {$y\{\}$};
	\node[vertex, below=1cm of defy] (itb2) {$\ast$};
	\node[vertex, below=1cm of itb2] (b3) {$b$};

		\tikzstyle{dot} = [draw,shape=circle,fill=blue!30, inner sep=0pt, minimum size=4pt]
		\node[dot, left=-2mm of con1] (con1in) {};
		\node[dot, right=-2mm of con1] (con1out) {};
		\node[dot, below=-2mm of con1] (con1mid) {};
		\node[dot, left=-2mm of defx] (defxin) {};
		\node[dot, right=-2mm of defx] (defxout) {};	
		\node[dot, fill=red,  left=-2mm of union] (unionin) {};
		\node[dot, right=-2mm of union] (unionout) {};
		\node[dot, left=-2mm of ita] (itain) {};
		\node[dot, right=-2mm of ita] (itaout) {};	
		\node[dot, left=-2mm of a1] (a1in) {};
		\node[dot, right=-2mm of a1] (a1out) {};
		\node[dot, left=-2mm of b1] (b1in) {};
		\node[dot, right=-2mm of b1] (b1out) {};
		\node[dot, left=-2mm of itb] (itbin) {};
		\node[dot, right=-2mm of itb] (itbout) {};
		\node[dot, left=-2mm of con2] (con2in) {};
		\node[dot, right=-2mm of con2] (con2out) {};
		\node[dot, below=-2mm of con2] (con2mid) {};	
		\node[dot, left=-2mm of x] (xin) {};
		\node[dot, right=-2mm of x] (xout) {};
		\node[dot, left=-2mm of y] (yin) {};
		\node[dot, right=-2mm of y] (yout) {};
		\node[dot, left=-2mm of it] (itin) {};
		\node[dot, right=-2mm of it] (itout) {};
		\node[dot, left=-2mm of con3] (con3in) {};
		\node[dot, right=-2mm of con3] (con3out) {};
		\node[dot, below=-2mm of con3] (con3mid) {};	
		\node[dot, left=-2mm of con4] (con4in) {};
		\node[dot, right=-2mm of con4] (con4out) {};
		\node[dot, below=-2mm of con4] (con4mid) {};	
		\node[dot, left=-2mm of b2] (b2in) {};
		\node[dot, right=-2mm of b2] (b2out) {};
		\node[dot, left=-2mm of defy] (defyin) {};
		\node[dot, right=-2mm of defy] (defyout) {};
		\node[dot, fill=red, left=-2mm of itb2] (itb2in) {};
		\node[dot, right=-2mm of itb2] (itb2out) {};
		\node[dot, left=-2mm of b3] (b3in) {};
		\node[dot, right=-2mm of b3] (b3out) {};
	

		\draw 	(con1in) edge[bend right] (defxin)
				(defxout) edge[bend right] (con1mid)
				(defxin) edge[bend right] node[left]{$[\,_x$} (unionin)
				(unionout) edge[bend right] node[right]{$]\,_x$} (defxout)
				(unionin) edge[bend right] node[above left=0.5cm and -0.8cm]{$avs(\gamma_{in})=\{x\}$} (itain)
				(unionin) edge[bend right] (itbin)
				(itain) edge[bend right=60] (itaout)
				(itaout) edge[bend right=60] (itain)
				(itain) edge[bend right] (a1in)
				(a1out) edge[bend right] (itaout)
				(itaout) edge[bend right] (unionout)
				(itbin) edge[bend right=60] (itbout)
				(itbout) edge[bend right=60] (itbin)
				(itbin) edge[bend right] (b1in)
				(b1out) edge[bend right] (itbout)
				(itbout) edge[bend right] (unionout)
				(a1in) edge[bend right=60] node[below]{\texttt{a}} (a1out)
				(b1in) edge[bend right=60] node[below]{\texttt{b}} (b1out)
				(con1mid) edge[bend right] (con2in)
				(con2in) edge[bend right] (xin)
				(xin) edge[bend right=60] node[below]{\texttt{x}} (xout)
				(xout) edge[bend right] (con2mid)
				(con2mid) edge[bend right] (itin)
				(itin) edge[bend right=60] (itout)
				(itout) edge[bend right=60] (itin)
				(itout) edge[bend right] (con2out)
				(con2out) edge[bend right] (con1out)
				(itin) edge[bend right] (con3in)
				(con3out) edge[bend right] (itout)
				(con3in) edge[bend right] (yin)
				(yin) edge[bend right=60] node[below]{\texttt{y}} (yout)
				(yout) edge[bend right] (con3mid)
				(con3mid) edge[bend right] (con4in)
				(con4in) edge[bend right] (b2in)
				(b2in) edge[bend right=60] node[below]{\texttt{b}} (b2out)
				(b2out) edge[bend right] (con4mid)
				(con4mid) edge[bend right] (defyin)
				(defyout) edge[bend right] (con4out)
				(con4out) edge[bend right] (con3out)
				(defyin) edge[bend right] node[left]{$[\,_y$} (itb2in)
				(itb2out) edge[bend right] node[right]{$]\,_y$} (defyout)
				(itb2in) edge[bend right=60] (itb2out)
				(itb2out) edge[bend right=60] (itb2in)
				(itb2in) edge[bend right] node[above left=0.5cm and 0cm]{$avs(\beta_{in})=\{y\}$}  (b3in)
				(b3out) edge[bend right] (itb2out)
				(b3in) edge[bend right=60] node[below]{\texttt{b}} (b3out);
				
				
\end{tikzpicture}
\caption{Graf $\mathcal{H}(x\{a^\ast+b^\ast\} \ x \ (yb \ y \{b^\ast\})^\ast)$}\label{fig:avdgraph}
\end{figure}

\begin{example} Nechť $\alpha = x\{a^\ast+b^\ast\} \ x \ (yb \ y \{b^\ast\})^\ast$ je regex z~$RV_{\{a, b\},\{x, y\}}$. Graf $\mathcal{H}(\alpha)$ je zobrazen na obrázku \ref{fig:avdgraph}. Všimněte si, že se na graf $\mathcal{H}(\alpha)$ lze podívat jako na graf přechodové funkce NKA s~$\varepsilon$-přechody $\mathcal{M} = (V(\mathcal{H}(\alpha)), \{a, b\}\cup\{x, y\}\cup\{[\,_x, [\,_y, ]\,_x, ]\,_y\}, \delta, \varphi_{in}, \{\varphi_{out}\})$ přijímajícího referenční jazyk $R(\alpha)$. Počáteční (resp. jediný koncový) stav automatu je $\varphi_{in}$ (resp. $\varphi_{out}$), kde $\varphi$ je kořen AST reprezentujícího regex $\alpha$.
\end{example}
 
Nechť $num$ je zobrazení z~$var(\alpha)$ do množiny $\{0, \dots, k-1\}$ takové, že pro každé dvě různé proměnné $x, y$ v~$\alpha$ platí $num(x) \ne num(y)$. z~grafu $\mathcal{H}(\alpha)$ lze vytvořit graf přechodové funkce $\delta$ substitucí každého výskyt proměnné $x$ v~ohodnocení nějaké hrany za $num(x)$. Potom $i$-tá paměť odpovídá proměnné označené číslem $i$ a výsledný automat $\mathcal{M} = (V(\mathcal{H}(\alpha)), \Sigma, \delta, \varphi_{in}, \{\varphi_{out}\})$ (kde $\varphi$ je kořen AST pro $\alpha$) přijímá jazyk $L(\alpha)$ \cite[s. 5]{schmidref}.

Příklad převodu regexu na memory automat pomocí uvedeného algoritmu lze najít v~příloze \ref{ukazka:avd}.

Jelikož konstrukce memory automatu pro regex je podobná konstrukci TS, výsledný $\mu$KA se také může zacyklit, pokud v~AST existuje vrchol reprezentující iteraci a hodnota výrazu potomka obsahuje $\varepsilon$ (viz příklad \ref{ex:cycle}). Při simulaci memory automatu je kontrolováno, jestli se konfigurace neopakují, obdobným způsobem, jako je tomu u TS.  

Algoritmus, který přijme na vstup regex $\alpha$ a vstupní slovo $w$, zkonstruuje ekvivalentní memory automat $\mathcal{M}$ a nasimuluje výpočet $\mathcal{M}$ pro vstup $w$, se v~této práci nazývá \texttt{simpleMemory}.

\begin{theorem}\label{thm:simplemem}
Časová složitost algoritmu \texttt{simpleMemory} je $\mathcal{O}(|\alpha|\cdot|w|^{k+1})$, kde $k = |var(\alpha)|$.
\end{theorem}
\begin{proof} Konstrukce grafu $H(\alpha)$ spotřebuje čas $\mathcal{O}(|\alpha|)$ \cite[lemma 3]{schmidref}. Simulace výsledného memory automatu potrvá $\mathcal{O}(|Q|\cdot|2|^k\cdot|w|^{k+1})$, kde $|Q| = \mathcal{O}(|\alpha|)$ \cite[lemma~2]{schmidref}.
\end{proof}

\iffalse
\section{Dvoucestný konečný automat}\label{sec:twoway}
V této sekci je popsán další výpočetní model přijímající REGEX jazyky. Dvoucestný konečný automat s~více čtecími hlavami se skládá z~řídící jednotky, read-only vstupní pásky a konečného počtu čtecích hlav, které se mohou pohybovat oběma směry. 
Při definování pojmů týkajících se dvoucestných automatů je vycházeno z~\cite{holzer}.
\begin{definition}
\emph{Nedeterministický dvoucestný KA s~k čtecími hlavami}, zkráceně \emph{2NKA($k$)}, je formálně definován jako osmice $M = \left(Q, \Sigma, k, \delta, \triangleright, \triangleleft, q_0, F\right)$, kde:
\begin{itemize}
	\item{$Q$ je konečná neprázdná množina vnitřních stavů,}
	\item{$\Sigma$ je neprázdná vstupní abeceda,}
	\item{$\triangleright$ je počáteční symbol pásky,}
	\item{$\triangleleft$ je koncový symbol pásky,}
	\item{$\delta$ : $\left(Q \times (\Sigma \cup \{\triangleright, \triangleleft \})^k\right) \rightarrow \wp\left( Q\times \{-1, 0, 1\}^k \right)$ je přechodová funkce,}
	\item{$q_0$ je počáteční stav,}
	\item{$F \subseteq Q$ je množina koncových stavů.}
\end{itemize}
\end{definition}

Definice přechodové funkce nám říká, že je-li $2NKA(k)$ v~nějakém stavu a čtecí hlavy na páskách ukazují na nějaké symboly z~vstupní abecedy, počáteční nebo koncový symbol, poté přejde automat do dalšího stavu a každou čtecí hlavu posune vlevo, vpravo nebo zůstane na místě.

\begin{definition}
Nechť $M = \left(Q, \Sigma, k, \delta, \triangleright, \triangleleft, q_0, F\right)$ je $2NKA(k)$.
\emph{Konfigurace} $M$ je trojice $\left(w, q, \langle p_1, \dots, p_k\rangle\right)$, kde:
\begin{itemize}
	\item{$w$ je obsah vstupní pásky,}
	\item{$q$ je aktuální stav,}
	\item{$p_i \in \{0, 1 \dots |w|+1\}$ je pozice $i$-té čtecí hlavy.}
\end{itemize}

Počáteční konfigurace $2NKA(k)$ $M$ pro vstup $w$ je konfigurace $$\left(w, q_0, \langle 1, \dots, 1\rangle\right)$$.

Buď $\alpha = \triangleright w \triangleleft$. \emph{Přechodem} $M$ se nazývá binární relace $\vdash_M$ na množině konfigurací definovaná následovně:
\begin{equation*}
\begin{split}
\left(w, q, \langle p_1, \dots, p_k \rangle\right) \vdash_M
\left(w, p,  \langle p_1+i_1, \dots, p_k+i_k \rangle \right) \\
\iff \left(p, \langle i_1, \dots, i_k \rangle \right) \in \delta\left(q, \langle \alpha[p_1], \dots, \alpha[p_k] \rangle \right)
\end{split}
\end{equation*}
\end{definition}

Dvoucestný KA s~více čtecími hlavami skončí výpočet, pokud je v~nějakém stavu $p$ a jeho čtecí hlavy ukazují na nějaké symboly $\alpha[i_1], \dots, \alpha[i_k]$ tak, že přechodová funkce pro tuto situaci není definována. Automat přijímá slovo $w$, jestliže přečtením $w$, přejde do koncového stavu a výpočet skončí.

\begin{definition}
\emph{Jazyk přijímaný 2NKA(k) M} je množina: 
\begin{equation*}
	\begin{split}
L\left(M\right) = \{ w \mid \left(\exists p \in F \right)  \left(\exists \alpha_1,\dots, \alpha_{k} \in \Sigma\cup\{\triangleright, \triangleleft\} \right) \left(\exists i_1, \dots, i_{k} \in \mathbb{N} \right) \\ 
\Big [ \left(w, q_0, \langle1, \dots, 1\rangle\right) \vdash_M^{\ast} \left(w, p, \langle i_1, \dots, i_k\rangle \right) \Big ] \ \wedge \ \delta(p, \langle \alpha[i_1], \dots, \alpha[i_k] \rangle) = \varnothing \}
\end{split}
\end{equation*}
\end{definition}

V této práci se používá graf přechodů pro znázornění přechodové funkce obousměrného automatu. Hrany grafu reprezentují přechody a jsou ohodnoceny posloupností $k$ dvojic z~množiny $(\Sigma\cup\{\triangleright, \triangleleft\}) \times \{-1, 0, 1\}$. Na $j$-té pozici se nachází dvojice $\langle \alpha_j, i_j \rangle$, kde $\alpha_j$ je čtený symbol, na nějž ukazuje $j$-tá čtecí hlava, a $i_j$ odpovídá pohybu této čtecí hlavy (viz obrázek \ref{fig:transtw}). 

\begin{figure}[ht] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
	\centering % centers the figure
	\begin{tikzpicture}% tikz code goes here
		\node[state] (q) {$q$};
		\node[state, right=7cm of q] (p) {$p$};
		\draw  (q) edge[below] node{$\big\langle \underbrace{\alpha_1}_{\substack{\text{čtený} \\ \text{symbol}}}, \underbrace{i_1}_{\substack{\text{pohyb} \\ \text{čtecí hlavy}}}\big\rangle, \dots, \langle \alpha_k, i_k \rangle $} (p);
	\end{tikzpicture}
	\caption{Znázornění přechodové funkce $2NKA(k)$ pomocí diagramu přechodů}
	\label{fig:transtw}
\end{figure}

\begin{algorithm}
		
  \caption{Simulace dvoucestného KA}\label{alg:twsim}
    \SetKwInOut{Input}{Vstup}
    \SetKwInOut{Output}{Výstup}
	\DontPrintSemicolon
    \Input{$2NKA(k)$ $M = \left(Q, \Sigma, k, \delta, \triangleright, \triangleleft, q_0, F\right)$, vstupní slovo $w$ } 
    \Output{$w \in L(M)$?}
    $tape \gets \triangleright w \triangleleft$\;
    $pos[0\dots,k-1]$ ; ($\forall i \in \{0,\dots, k-1\}$) $pos[i]\gets1$\;
    $curState \gets q_0$ \;  
\SetAlgoLined
\SetKwFunction{Build}{accepts}
\SetKwFunction{Trans}{getTrans}
\SetKwFunction{Cp}{getCopy}
\SetKwFunction{Exec}{execTrans}
\SetKwProg{Def}{def}{}{}
\Def{\Build{$curState$, $tape$, $pos$}}{
	$transitions \gets$ \Trans{$curState$, $tape$, $pos$}\;
	\lIf{$curState \in F \ \wedge \ |transitions|=0$} {\KwRet true}
	\uElse{\For{$i\gets0$ \KwTo $|transitions|$}{
	$posCopy  \gets $\Cp{$pos$}\;
	$stateCopy \gets $\Cp{$curState$}\;
	\Exec{$transitions[i]$, $stateCopy$, $tape$, $posCopy$}\;
	\uIf{\Build{$stateCopy$, $tape$, $posCopy$}}{\KwRet true }
	}}
	\KwRet false
}
\

\KwRet \Build{$curState$, $tape$, $pos$}\;
\end{algorithm}

Algoritmus \ref{alg:twsim} lze použít pro simulaci výpočtu dvoucestného KA pro vstupní slovo $w$. Funkce $accepts$ má tři vstupní parametry, které jednoznačně určují aktuální konfiguraci 2NKA. Na začátku se zavolá tato funkce se vstupními parametry, které odpovídají počáteční konfigurace automatu. Funkce vrátí hodnotu $true$, pokud je na vstupu koncová konfigurace $2NKA(k)$. Jinak pro každý přechod algoritmus vytvoří novou konfiguraci a zavolá rekurzivně funkci $accepts$. Na rozdíl od algoritmu pro simulaci TS není nutné kopírovat obsah pásky, protože páska dvoucestného KA je read-only.

\fi

\iffalse
\section{Algoritmus pro převod regexu na dvoucestný KA}

V této sekci je formálně popsán algoritmus pro převod regexu na ekvivalentní dvoucestný konečný automat. Základní myšlenka algoritmu konstrukce je založena na pozorování z~\cite[s. 21--22]{schmidthesis}.
\begin{pozorovani} Čtecí hlava $2NKA(k)$ může sloužit jako čítač. Hodnota takového čítače odpovídá pozici hlavy na pásce a může nabývat hodnot $0$ až $|w+1|$. Inkrementace (resp. dekrementace) je potom posun doprava (resp. doleva). 
\end{pozorovani}

Nechť $num$ je zobrazení z~$var(\alpha)$ do množiny $\{1, \dots, k\}$ takové, že pro každé dvě různé proměnné $x, y$ v~$\alpha$ platí $num(x) \ne num(y)$. Potom $i$-tá páska odpovídá proměnné označené číslem $i$. Zavedeme také tabulku $T[1, \dots, k]$, kde $T[i] = 1$ právě, když automat čte řetězec, který odpovídá hodnotě výrazu v~definici proměnné $num^{-1}(i)$. 


\begin{algorithm}
		
  \caption{Převod regexu na dvoucestný KA}\label{alg:twoway}
    \SetKwInOut{Input}{Vstup}
    \SetKwInOut{Output}{Výstup}
	\DontPrintSemicolon
    \Input{AST s~kořenem $\varphi$ reprezentující regex $\alpha \in RV_{\Sigma, X}$} 
    \Output{$2NKA(3k+2)$ $\mathcal{M}$ takový, že $L(M)=L(\alpha)$} \tcc{$k$ je počet proměnných v~$\alpha$ ($k = |var(\alpha)|$)}
    $num : X \rightarrow \{1, \dots, k\}$; ($\forall x, y \in X$)  $num(x)=num(y) \Rightarrow x=y$\; ($\forall i \in \{1, \dots, k\}$) $ T[i] \gets 0$\;
    $Q \gets \{start, p, end\}$; $F \gets \{end\}$\;
    uprav $\delta$ podle (\ref{itm:init})\;
	
\SetAlgoLined
\SetKwFunction{Build}{build-TW}
\SetKwFunction{BuildM}{modify}
\SetKwProg{Def}{def}{}{}
\Def{\Build{$\beta$, $q_{start}$, $q_{end}$}}{

\uIf{$type(\beta) = atomic$}{
		$p \notin Q$; $Q \leftarrow Q \cup \{p\}$\;
  \lIf{$\beta.value = \varepsilon$}{uprav $\delta$ podle (\ref{itm:eps2})}
  \lElseIf{$\beta.value = \varnothing$}{uprav $\delta$ podle (\ref{itm:nothing2}) }
  \lElse{uprav $\delta$ podle (\ref{itm:symbol2})
  }
	  }
	\uElseIf{$type(\beta) = union$}{
	$q_{start}^{l}, q_{start}^{r}, q_{end}^{l}, q_{end}^{r} \notin Q$; $Q \leftarrow Q \cup \{q_{start}^{l}, q_{start}^{r}, q_{end}^{l}, q_{end}^{r}\}$\;
	 uprav $\delta$ podle (\ref{itm:union2})\;
	 \Build{$\beta.left$, $q_{start}^{l}$, $q_{end}^{l}$} ; \Build{$\beta.right$, $q_{start}^{r}$, $q_{end}^{r}$}
       }
	\uElseIf{$type(\beta) = concatenation$}{
	$q_{start}^{l}, q_{start}^{r}, q_{end}^{l}, q_{end}^{r}, q_{mid}  \notin Q$; $Q \leftarrow Q \cup \{q_{start}^{l}, q_{start}^{r}, q_{end}^{l}, q_{end}^{r}, q_{mid}\}$\;
		uprav $\delta$ podle \ref{itm:concat2}\;
		\Build{$\beta.left$, $q_{start}^{l}$, $q_{end}^{l}$} ; \Build{$\beta.right$, $q_{start}^{r}$, $q_{end}^{r}$}
	}

	\uElseIf{$type(\beta) = iteration$}{
	$q_{start}^{\alpha}, q_{end}^{\alpha}  \notin Q$; $Q \leftarrow Q \cup \{q_{start}^{\alpha}, q_{end}^{\alpha}\}$\;
		uprav $\delta$ podle (\ref{itm:iter2})\;
		\Build{$\beta.inner$, $q_{start}^{\alpha}$, $q_{end}^{\alpha}$}
	}

	\uElseIf{$type(\beta) = definition$}{
       $p, q, r, q_{start}^{\alpha}, q_{end}^{\alpha}  \notin Q$; $Q \leftarrow Q \cup \{p, q, r, q_{start}^{\alpha}, q_{end}^{\alpha}\}$\;
		uprav $\delta$ podle (\ref{itm:def2})\;
		$T[num(\beta.var)] \gets 1$\;
		\Build{$\beta.inner$, $q_{start}^{\alpha}$, $q_{end}^{\alpha}$}\;
		$T[num(\beta.var)] \gets 0$\;
	}

	\uElseIf{$type(\beta) = reference$}{
       $p, q  \notin Q$\; $Q \leftarrow Q \cup \{p, q\}$\;
		 uprav $\delta$ podle (\ref{itm:ref2})\;
	}
}
\

\Build{$\varphi$, $start$, $p$}\;
$\mathcal{M}=(Q, \Sigma, k, \delta, \triangleright, \triangleleft, start, F)$\;
\KwRet $\mathcal{M}$\;
  
\end{algorithm}

Algoritmus \ref{alg:twoway} dostane na vstup ukazatel na kořen AST reprezentující regex $\alpha$, projde rekurzivně vrcholy tohoto stromu a přidá odpovídající přechody do přechodové funkce automatu. Výsledný dvoucestný KA $\mathcal{M}$ má počáteční stav $start$, jediný koncový stav $end$ a následující vlastnosti:
\begin{itemize}
	\item{$\mathcal{M}$ je $2NKA(3 k~+ 2)$, kde $k$ je počet proměnných v~$\alpha$.}
	\item{Nulté čtecí hlavě se říká \emph{vstupní}. Tato hlava bude postupně procházet vstupní slovo zleva doprava a nikdy se neposune doleva. Druhá čtecí hlava funguje jako čítač délky dosud přečteného řetězce (dále \emph{hlavní čítač}).}
	\item{Ke každé proměnné, která se alespoň jednou ve výrazu vyskytuje, jsou přiřazeny tři čtecí hlavy. První ukazuje na začátek podřetězce, který odpovídá hodnotě dílčího výrazu uvnitř definice, ostatní fungují jako čítače. Na začátku hodnoty dvou čítačů se rovnají 0. Po přijetí podřetězce, který odpovídá hodnotě výrazu uvnitř definice, hodnota čítače č. 1 je nastavena na jeho délku. Počáteční konfigurace tedy je $$\left(w, start, \langle \underbrace{1, 0}, \underbrace{1, 0, 0},\dots,\underbrace{1, 0, 0}\rangle\right)$$}
\item{Řetězec odpovídající zpětné referenci na nějakou proměnnou bude přijat tak, že se porovnají $n$ (kde $n$ je hodnota čítače č. 1) symbolů, počínaje symbolem, na nějž ukazuje čtecí hlava pro tuto proměnnou, se symboly, na něž ukazuje vstupní hlava. Při porovnávání řetězců se čítač č. 1 dekrementuje a druhý čítač se inkrementuje. Pomocí čítače č. 2 automat přepočítá počáteční pozici, na kterou ukazovala první čtecí hlava pro proměnnou. }
\end{itemize}

Jelikož \textit{2NKA} přijímá koncovým stavem a má \textit{read-only} pásku, je nutné přidat nový stav $p$ a přechody ze stavu $p$ do $end$, při kterých \textit{vstupní} čtecí hlava přečte koncový znak $\triangleleft$. Uvedené kroky lze formálně popsat takto (viz obrázek \ref{fig:init}):

\begin{figure}[ht] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
	\centering % centers the figure
	\begin{tikzpicture}% tikz code goes here
		\node[state] (start) {$p$};
		\node[state, accepting, right=6cm of start] (end) {$end$};
		\draw  	(start) edge[above] node{$\Big\langle \triangleleft, 0\Big\rangle, \Big\langle x_{1}, 0\Big\rangle,\dots, \Big\langle x_{3k+1}, 0\Big\rangle$} (end);
	\end{tikzpicture}
	\caption{Přechod do koncového stavu pro $2NKA$ přijímající regex}
	\label{fig:init}
\end{figure}

	Pro $\forall x_1, \dots, x_{3k+1} \in G$ se vytvoří přechody:

        \begin{equation}\begin{split}\label{itm:init}\delta(p, \langle \triangleleft, x_1,\dots, x_{3k+1} \rangle)\leftarrow\delta(p, \langle  \triangleleft, x_{1}, \dots, x_{3k+1} \rangle)\cup \\  \{(end, \langle 0,\dots, 0\rangle)\}\end{split}\end{equation}

Dále je popsána činnost rekurzivní funkce \texttt{build-TW} podle typu uzlu, který je dán vstupním parametrem $\beta$:
\begin{enumerate}
 \item{Prvním typem uzlu je elementární výraz. Může nastat jeden z~následujících případů:}
\begin{enumerate}
\item \label{itm:eps2}{Uzel reprezentuje prázdný řetězec. Potom se přidají \uv{$\varepsilon$-přechody} ze stavu $q_{start}$ do stavu $q_{end}$. 
	 Pod pojmem \uv{$\varepsilon$-přechod} je myšleno přechod, při kterém automat nepřečte žádný symbol a neposune žádnou čtecí hlavu. Počet přechodů je roven počtu $(3k+1)$-členných variací s~opakováním z~$|\Sigma \cup \{\triangleright, \triangleleft\}|$ prvků ($(|\Sigma|+2)^{3k+2}$).

	Buď $G := \Sigma \cup  \{\triangleright, \triangleleft\}$. Pro $\forall x_0, \dots, x_{3k+1} \in G$ se přechodová funkce modifikuje následovně (viz obrázek \ref{fig:eps2}):
	
	$\delta(q_{start}, \langle  x_0, \dots, x_{3k+2}\rangle)\leftarrow\delta(q_{start}, \langle  x_0, \dots, x_{3k+1}\rangle)\cup\{(q_{end}, \langle 0, \dots, 0\rangle)\}$
	}
	
\begin{figure}[ht] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
	\centering % centers the figure
	\begin{tikzpicture}% tikz code goes here
		\node[state, dashed] (start) {$q_{start}$};
		\node[state, right=4.5cm of start] (end) {$q_{end}$};
		\draw  	(start) edge[above] node{$\Big\langle x_0, 0\Big\rangle,\dots, \Big\langle x_{3k+1}, 0\Big\rangle$} (end);
	\end{tikzpicture}
	\caption{Ukázka sestavení $2NKA(3k+2)$ při průchodu uzlem reprezentujícím výraz $\varepsilon$}
	\label{fig:eps2}
\end{figure}
 
    \item \label{itm:nothing2}{Dalším typem uzlu je prázdný regulární výraz. Přidají se \uv{$\varepsilon$-přechody} ze stavu $q_{start}$ do nového stavu $p$. Stav $p$ zde zastává funkci \uv{nulového} stavu (přechodová funkce $\delta$ neobsahuje žádný přechod ze stavu $p$ na nějaký další stav).

	Pro $\forall x_0, \dots, x_{3k+1} \in G$ se provede úprava přechodové funkce automatu následovně (viz obrázek \ref{fig:nothing2}):
	
	$\delta(q_{start}, \langle  x_0, \dots, x_{3k+1}\rangle)\leftarrow\delta(q_{start}, \langle  x_0, \dots, x_{3k+1}\rangle)\cup\{(p, \langle 0 \dots, 0\rangle)\}$

	}
	
	\begin{figure}[ht] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
	\centering % centers the figure
	\begin{tikzpicture}% tikz code goes here
		\node[state, dashed] (start) {$q_{start}$};
		\node[state, right of=start] (p) {$p$};
		\node[state, dashed, right=2cm of p] (end) {$q_{end}$};
		\draw  	(start) edge[above] node{$\Big\langle x_0, 0\Big\rangle, \dots, \Big\langle x_{3k+1}, 0\Big\rangle$} (p);
	\end{tikzpicture}
	\caption{Ukázka sestavení $2NKA(3k+2)$  při průchodu uzlem reprezentujícím prázdný regulární výraz}
	\label{fig:nothing2}
\end{figure}

	\item \label{itm:symbol2}{Posledním elementárním výrazem je symbol abecedy. Ze stavu $q_{start}$ po přečtení symbolu abecedy, na nějž ukazuje vstupní čtecí hlava, inkrementuje odpovídající čítače, pokud se symbol nachází uvnitř definice proměnné, a přejde do stavu $q_{end}$ (viz obrázek \ref{fig:symbol2}). 
	Uvedené kroky lze formálně popsat takto:

	Pro $\forall x_0, x_1, \dots, x_{3k} \in G$ a nějaký symbol abecedy $a$ se přidají přechody:

        \begin{equation*}\begin{split}\delta(q_{start}, \langle a, x_0, x_1,\dots, x_{3i-1}. \dots \rangle)\leftarrow\delta(q_{start}, \langle  a, x_0, x_{1}, \dots, x_{3i-1}, \dots\rangle)\cup \\  \{(p, \langle 1, 1, 0,\dots, \overbrace{1}^{3i-1; T[i]=1},  \dots \rangle)\}\end{split}\end{equation*}

	}

\begin{figure}[ht] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
	\centering % centers the figure
	\begin{tikzpicture}% tikz code goes here
		\node[state, dashed] (start) {$q_{start}$};
		\node[state, dashed, right=6cm of start] (end) {$q_{end}$};
		\draw  	(start) edge node[above]{$\Big \langle a, 1 \Big \rangle, \Big \langle x_0, 1 \Big \rangle, \dots, \overbrace{ \Big\langle x_{3i-1}, 1 \Big\rangle}^{T[i]=1}, \dots$} (end);
	\end{tikzpicture}
	\caption{Ukázka sestavení $2NKA(3k+2)$ při průchodu uzlem reprezentujícím výraz $a$}
	\label{fig:symbol2}
\end{figure}
	\end{enumerate}
 
	 \item{Dalším typ vrcholu je binární operátor. Algoritmus zachází s~binárním operátorem podobně jako algoritmus \ref{alg:turing}. Pro takovýto případ se do množiny stavů pro každý operand přidají \uv{počáteční} a \uv{koncový} stav (například stavy $q_{start}^{l}$ a $q_{end}^{l}$ pro levý operand). Algoritmus začne rekurzivně procházet pravého a levého potomka a přidávat pro ně nové stavy a přechody do automatu.}
   \begin{enumerate}
	   \item \label{itm:union2}{Pokud při průchodu algoritmus narazí na uzel reprezentující sjednocení dvou výrazů, jednoduše se přidají \uv{$\varepsilon$-přechody} mezi stavem $q_{start}$ a \uv{počátečními} stavy pro potomky a z~\uv{koncových} stavů do stavu $q_{end}$.
	
	Pro $\forall x_0, \dots, x_{3k+1} \in G$ se přechodová funkci modifikuje následovně:
	
	$\delta(q_{start}, \langle  x_0, \dots, x_{3k+1}\rangle)\leftarrow\delta(q_{start}, \langle  x_0, \dots, x_{3k+1}\rangle)\cup\{(q_{start}^{l}, \langle 0, \dots , 0\rangle)\}$

	$\delta(q_{start}, \langle  x_0, \dots, x_{3k+1}\rangle)\leftarrow\delta(q_{start}, \langle  x_0, \dots, x_{3k+1}\rangle)\cup\{(q_{start}^{r}, \langle 0, \dots , 0\rangle)\}$
	
	$\delta(q_{end}^{l}, \langle  x_0, \dots, x_{3k+1}\rangle)\leftarrow\delta(q_{end}^{l}, \langle  x_0, \dots, x_{3k+1}\rangle)\cup\{(q_{end},  \langle 0, \dots , 0\rangle)\} $

	$\delta(q_{end}^{r}, \langle  x_0, \dots, x_{3k+1}\rangle)\leftarrow\delta(q_{end}^{r}, \langle  x_0, \dots, x_{3k+1}\rangle)\cup\{(q_{end}, \langle 0, \dots , 0\rangle)\} $
	}

	 \item \label{itm:concat2}{Další typ uzlu, na který lze při průchodu narazit, je zřetězení. Pro tento typ uzlu se do množiny stavů automatu přidá nový stav $q_{mid}$. 
	
	Pro $\forall x_0, \dots, x_{3k+1} \in G$ se přechodová funkce upraví takto:

		$\delta(q_{start}, \langle  x_0, \dots, x_{3k+1}\rangle)\leftarrow\delta(q_{start}, \langle  x_0, \dots, x_{3k+1}\rangle)\cup\{(q_{start}^{l}, \langle 0, \dots, 0\rangle)\}$

		$\delta(q_{mid}, \langle  x_0, \dots, x_{3k+1}\rangle)\leftarrow\delta(q_{mid}, \langle  x_0, \dots, x_{3k+1}\rangle)\cup\{(q_{start}^{r}, \langle 0, \dots, 0\rangle)\}$

		$\delta(q_{end}^{l}, \langle  x_0, \dots, x_{3k+1}\rangle)\leftarrow\delta(q_{end}^{l}, \langle  x_0, \dots, x_{3k+1}\rangle)\cup\{(q_{mid}, \langle 0, \dots,  0\rangle)\} $

		$\delta(q_{end}^{r}, \langle  x_0, \dots, x_{3k+1}\rangle)\leftarrow\delta(q_{end}^{r}, \langle  x_0, \dots, x_{3k+1}\rangle)\cup\{(q_{end}, \langle 0, \dots, 0\rangle)\} $
	}

   \end{enumerate}
    \item{Při průchodu lze také narazit na unární operátor nebo definice proměnné. Potom se do množiny stavů přidají nové stavy $q_{start}^{\alpha}$ a  $q_{start}^{\alpha}$ pro potomka.}
	\begin{enumerate}
	 \item \label{itm:iter2}{Jediným unárním operátorem, na nějž lze narazit při průchodu, je iterace. Podobně jako v~algoritmu \ref{alg:turing} pro takovýto případ algoritmus vytvoří \uv{$\varepsilon$-přechody} mezi stavy a začne rekurzivně procházet uzlem potomka.
	
	Pro $\forall x_0, \dots, x_{3k+1} \in G$ se přidají přechody takto:

		$\delta(q_{start}, \langle  x_0, \dots, x_{3k+1}\rangle)\leftarrow\delta(q_{start}, \langle  x_0, \dots, x_{3k+1}\rangle)\cup\{(q_{end}, \langle 0, \dots, 0\rangle)\}$

		$\delta(q_{start}, \langle  x_0, \dots, x_{3k+1}\rangle)\leftarrow\delta(q_{start}, \langle  x_0, \dots, x_{3k+1}\rangle)\cup\{(q_{start}^{\alpha}, \langle 0, \dots, 0\rangle)\}$

		$\delta(q_{end}^{\alpha}, \langle  x_0, \dots, x_{3k+1}\rangle)\leftarrow\delta(q_{end}^{\alpha}, \langle  x_0, \dots, x_{3k+1}\rangle)\cup\{(q_{start}^{\alpha}, \langle 0, \dots, 0\rangle)\} $

		$\delta(q_{end}^{\alpha}, \langle  x_0, \dots, x_{3k+1}\rangle)\leftarrow\delta(q_{end}^{\alpha}, \langle  x_0, \dots, x_{3k+1}\rangle)\cup\{(q_{end}, \langle 0, \dots, 0\rangle)\} $

	}

	 \item \label{itm:def2}{Dalším typem uzlu je definice proměnné. Jelikož pro libovolnou proměnnou $y$ jsou vyhrazeny tři čtecí hlavy ($num(y)-1$ až $num(y)+1$) a definice proměnné se může opakovat ve výrazů několikrát, je nutné nejprve vynulovat čítač pro danou proměnnou a aktualizovat pozici pracovní čtecí hlavy (viz obrázek \ref{fig:def2}). Pak algoritmus \uv{povolí} inkrementaci pro první čítač ($num(y)$). Po skončení $2NKA$ \uv{zakáže} inkrementaci a automat přejde do koncového stavu $q_{end}$. 

	Pro  $\forall x_0, \dots, x_{3k+1} \in G$, $\forall x_{3num(y)-1}, x_{3num(y)+1} \in \Sigma$ se přechodová funkce modifikuje následovně:
	
	$\delta(q_{start}, \langle  x_0, \dots, x_{3k+1}\rangle)\leftarrow\delta(q_{start}, \langle  x_0, \dots, x_{3k+1}\rangle)\cup\{(q, \langle 0, \dots, 0\rangle)\}$
	 \begin{equation*}\begin{split}\delta(q, \langle  x_0, \dots, x_{3num(y)-1}, \dots, x_{3num(y)+1},\dots \rangle)\leftarrow\\\delta(q, \langle  x_0, \dots, x_{3num(y)-1}, \dots, x_{3num(y)+1},\dots \rangle)\cup\{(q, \langle 0, \dots, -1, \dots, -1, \dots\rangle)\}\end{split}\end{equation*}

	$\delta(q, \langle  x_0, \dots, \triangleright, \dots, x_{3num(y)+1},\dots \rangle)\leftarrow\delta(q, \langle  x_0, \dots, \triangleright, \dots, x_{3num(y)+1},\dots \rangle)\cup\{(q, \langle 0, \dots, 0, \dots, -1, \dots\rangle)\}$

	$\delta(q, \langle  x_0, \dots, x_{3num(y)-1}, \dots, \triangleright,\dots \rangle)\leftarrow\delta(q, \langle  x_0, \dots, x_{3num(y)-1}, \dots, \triangleright,\dots \rangle)\cup\{(q, \langle 0, \dots, -1, \dots, 0, \dots\rangle)\}$

	$\delta(q, \langle  x_0, \dots, \overbrace{\triangleright}^{3num(y)-1}, \dots, \overbrace{\triangleright}^{3num(y)+1},\dots \rangle)\leftarrow\delta(q, \langle  x_0, \dots, \triangleright, \dots, \triangleright,\dots \rangle)\cup\{(p, \langle 0, \dots, 0\rangle)\}$

	 \begin{equation*}\begin{split}\delta(p, \langle  x_0, x_1, \dots, x_{3num(y)-1}, \dots, x_{3num(y)+1},\dots \rangle)\leftarrow\\\delta(p, \langle  x_0, x_1, \dots, x_{3num(y)-1}, \dots, x_{3num(y)+1},\dots \rangle)\cup\{(p, \langle 0, -1, \dots, 1, \dots, 1, \dots\rangle)\}\end{split}\end{equation*}

	$\delta(p, \langle  x_0, \triangleright, x_2, \dots \rangle)\leftarrow\delta(p, \langle  x_0, \triangleright, x_2, \dots \rangle)\cup\{(r, \langle 0, \dots, 0\rangle)\}$

	$\delta(r, \langle  x_0, x_1, \dots, x_{3num(y)+1},\dots \rangle)\leftarrow\delta(r, \langle  x_0, x_1, \dots, x_{3num(y)+1},\dots \rangle)\cup\{(r, \langle 0, 1, \dots, -1, \dots\rangle)\}$

	$\delta(r, \langle  x_0, \dots, \overbrace{\triangleright}^{3num(y)+1}, \dots \rangle)\leftarrow\delta(p, \langle  x_0, \dots, \triangleright, \dots \rangle)\cup\{(q_{start}^{\alpha}, \langle 0, \dots, 0\rangle)\}$

	$\delta(q_{end}^{\alpha}, \langle  x_0, \dots, x_{3k+1}\rangle)\leftarrow\delta(q_{end}^{\alpha}, \langle  x_0, \dots, x_{3k+1}\rangle)\cup\{(q_{end}, \langle 0, \dots, 0\rangle)\}$
	}
	
\begin{figure}[ht] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
	\centering % centers the figure
	\begin{tikzpicture}% tikz code goes here
		\node[state, dashed] (start) {$q_{start}$};
		\node[state, below=3cm] (q) {$q$};
		\node[state, above right=2cm and 4.5cm of q] (p) {$p$};
		\node[state, below right=2cm and 3.5cm of p] (r) {$r$};
		\node[state, below= 2cm of r] (sl) {$q_{start}^{\alpha}$};
		\node[state, left=2cm of sl] (el) {$q_{end}^{\alpha}$};
		\node[state, dashed, below left = 1cm and 2cm of el] (end) {$q_{end}$};
		\node[draw, below=0.5cm of sl] (t1) {$T[num(y)] \leftarrow 1$};
		\node[draw, below=0.5cm of el] (t2) {$T[num(y)] \leftarrow 0$};
		\draw  	(start) edge node[left=0.25cm]{$\Big\langle x_0, 0\Big\rangle, \dots$} (q)
				(q) edge[loop below] node{$\dots, \Big\langle x_{3num(y)-1}, -1\Big\rangle, \dots, \Big\langle x_{3num(y)+1}, -1\Big\rangle, \dots$} node[below=0.8cm]{$\dots, \Big\langle \triangleright, 0\Big\rangle, \dots, \Big\langle  x_{3num(y)+1}, -1\Big\rangle, \dots$} node[below=1.6cm]{$\dots, \Big\langle  x_{3num(y)-1}, -1 \Big\rangle, \dots, \Big\langle \triangleright, 0\Big\rangle, \dots$} (q)
				(q) edge node[above=0.25cm, rotate=30]{$\dots, \overbrace{\Big\langle \triangleright, 0\Big\rangle}^{3num(y)-1}, \dots, \overbrace{\Big\langle \triangleright, 0\Big\rangle}^{3num(y)+1}, \dots$} (p)
				(p) edge[loop above] node[above=0.25cm]{$\dots, \Big\langle x_{1}, -1\Big\rangle, \dots, \Big\langle x_{3num(y)-1}, 1\Big\rangle, \dots, \Big\langle x_{3num(y)+1}, 1\Big\rangle, \dots$} (p)
				(p) edge node[above=0.25, rotate=324]{$\dots, \overbrace{\Big\langle \triangleright, 0\Big\rangle}^{1.},\dots$} (r)
				(r) edge[loop left] node[left=0.25cm]{$\dots, \Big\langle x_{1}, 1\Big\rangle, \dots, \Big\langle x_{3num(y)+1}, -1\Big\rangle, \dots$} (r)
				(r) edge node[left=0.25cm]{$\dots, \overbrace{\Big\langle \triangleright, 0\Big\rangle}^{3num(y)+1},\dots$} (sl)
				(el) edge node[above, rotate=33]{$\Big\langle x_0, 0\Big\rangle, \dots$} (end);
		\draw[dashed, fill=red, draw=black, opacity=0.15] (el) circle [xshift=1.6cm, y radius=1.1cm, x radius=2.5cm] node[xshift=1.6cm, opacity=1] {$N(\alpha)$};
		
	\end{tikzpicture}
	\caption{Ukázka sestavení $2NKA(3k+2)$ při průchodu uzlem reprezentujícím definici proměnné $y\{\alpha\}$}
	\label{fig:def2}
\end{figure}

	\end{enumerate}
	\item \label{itm:ref2}{Poslední typ uzlu, na který lze narazit při průchodu, je zpětná reference. Automat začne porovnávat symboly, na které ukazuje vstupní čtecí hlava, se symboly, na které ukazuje pracovní čtecí hlava pro danou proměnnou. Na konci aktualizuje pozici pracovní hlavy pomocí čítače č.~2 (viz obrázek \ref{fig:ref2}).

Pro  $\forall x_0, \dots, x_{3k+1} \in G$, $\forall z, x_{3num(y)-1}, x_{3num(y)} x_{3num(y)+1} \in \Sigma$ se přidají následující přechody:

	$\delta(q_{start}, \langle  x_0, \dots, x_{3k+1}\rangle)\leftarrow\delta(q_{start}, \langle  x_0, \dots, x_{3k+1}\rangle)\cup\{(p, \langle 0, \dots, 0\rangle)\}$

	 \begin{equation*}\begin{split}\delta(p, \langle  z, \dots, z, x_{3num(y)}, x_{3num(y)+1},\dots \rangle)\leftarrow\\\delta(p, \langle z, \dots, z, x_{3num(y)}, x_{3num(y)+1},\dots \rangle)\cup\{(p, \langle 1, \dots, 1, -1, 1 \dots\rangle)\}\end{split}\end{equation*}

	 \begin{equation*}\begin{split}\delta(q, \langle  x_0, \dots,  x_{3num(y)-1}, x_{3num(y)}, x_{3num(y)+1},\dots \rangle)\leftarrow\\\delta(q, \langle x_0 \dots, x_{3num(y)-1}, x_{3num(y)}, x_{3num(y)+1},\dots \rangle)\cup\{(p, \langle 0, \dots, -1, 1, -1 \dots\rangle)\}\end{split}\end{equation*}

	$\delta(p, \langle  x_0, \dots, \overbrace{\triangleright}^{3num(y)}, \dots \rangle)\leftarrow\delta(p, \langle  x_0, \dots, \triangleright, \dots \rangle)\cup\{(q, \langle 0, \dots, 0\rangle)\}$

	$\delta(q, \langle  x_0, \dots, \overbrace{\triangleright}^{3num(y)+1}, \dots \rangle)\leftarrow\delta(q, \langle  x_0, \dots, \triangleright, \dots \rangle)\cup\{(q_end, \langle 0, \dots, 0\rangle)\}$
	}

\begin{figure}[ht] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
	\centering % centers the figure
	\begin{tikzpicture}% tikz code goes here
		\node[state, dashed] (start) {$q_{start}$};
		\node[state, above right=2cm and 3cm of start] (p) {$p$};
		\node[state, below right= 2cm and 3cm of p] (q) {$q$};
		\node[state, dashed, right=2.5cm of q] (end) {$q_{end}$};
		\draw (start) edge node[above=0.25cm, rotate=37]{$\Big\langle x_0, 0\Big\rangle, \dots$} (p)
				(p) edge[loop above] node{$\Big\langle z, 1\Big\rangle, \dots, \Big\langle z, 1\Big\rangle, \Big\langle x_{3num(y)}, -1\Big\rangle, \Big\langle x_{3num(y)+1}, 1\Big\rangle, \dots$} (p)
				(p) edge node[above right]{$ \dots, \overbrace{\Big\langle \triangleright, 0\Big\rangle}^{3num(y)}\dots$} (q)
				(q) edge[loop below] node[below]{$\dots, \Big\langle x_{3num(y)-1}, -1\Big\rangle, \Big\langle x_{3num(y)}, 1\Big\rangle, \Big\langle x_{3num(y)+1}, -1\Big\rangle, \dots$} (q)
				(q) edge node[above]{$\dots, \overbrace{\Big\langle \triangleright, 0\Big\rangle}^{3num(y)+1}\dots$} (end);
		
	\end{tikzpicture}
	\caption{Ukázka sestavení $2NKA(3k+2)$ při průchodu uzlem reprezentujícím zpětnou referenci na proměnnou $y$}
	\label{fig:ref2}
\end{figure}
\end{enumerate}

\begin{theorem}
	Časová složitost algoritmu \ref{alg:twoway} je $\mathcal{O}(|\alpha| \cdot |\Sigma|^{3k+2} )$.
\end{theorem}
\begin{proof}  Inicializace algoritmu (kroky 1 až 3) trvá $\mathcal{O}(k)$. Algoritmus rekurzivně prochází každý uzel syntaktického stromu právě jednou, tedy se celkem provede $\mathcal{O}(|\alpha|)$ volání funkce \texttt{build-TW}. v~každém volání se do množiny stavů přidají maximálně $5$ stavů (krok 31) a vytvoří se nejvýše $(|\Sigma|+2)^{3k} \cdot (4|\Sigma|^2 + 10|\Sigma|+9)$ přechodů (krok 32). Celkově tedy algoritmus spotřebuje čas $\mathcal{O}(|\alpha| \cdot |\Sigma|^{3k+2} )$. 
\end{proof}

\begin{pozorovani}\label{poz:out}Výstup algoritmu \ref{alg:twoway} je $2NKA(3k+2)$ $\mathcal{M}$, který má následující vlastnost. Pro libovolnou konfiguraci $\varphi = \left(w, q, \langle p_1, \dots, p_{3k+2}\rangle\right)$ platí $|\{p  \mid \varphi \vdash_{\mathcal{M}} p\}|\le2$.
\end{pozorovani}

\begin{theorem}\label{thm:ctime}Algoritmus pro zpracování regexu $\alpha \in RV_{\Sigma, X}$ založený na konstrukci dvoucestného KA pracuje v~čase $\mathcal{O}(|\alpha|\cdot(|w|^{3k+2} + |\Sigma|^{3k+2}))$, kde $k$ je počet definic v~$\alpha$. \end{theorem}
Z pozorování \ref{poz:out} vyplývá, že simulace $2NKA$ $\mathcal{M}$, který je výstupem algoritmu \ref{alg:twoway}, spotřebuje čas $\mathcal{O}(|Q|\cdot|w|^{3k+2})$ (kde $Q$ ke množina stavů $M$). Jelikož platí $Q=\mathcal{O}(|\alpha|)$ a konstrukce $2NKA$ spotřebuje čas $\mathcal{O}(|\alpha|\cdot|\Sigma|^{3k+2})$, celkem zpracování regexu $\alpha$ trvá $\mathcal{O}(|\alpha|\cdot|w|^{3k+2} + |\alpha|\cdot|\Sigma|^{3k+2})$.
\fi
\chapter{Parametrizovaná složitost zpracování regexů}

Problém zpracování regexů patří mezi problémy, jejichž parametrizovaná složitost dosud nebyla podrobně zkoumána. Věta \ref{thm:simplemem} nám poskytuje algoritmus pracující v~čase $\mathcal{O}(|I|^{k+1})$, kde $k$ je součástí vstupu $I$. Lze proto tvrdit, že parametrizovaný problém \ref{prob} patří do třídy XP.

Cílem této kapitoly je prozkoumat společnou vlastnost (parametr) vstupů a vlastnost regexů, na níž je tento parametr závislý. v~této kapitole bude vycházeno z~\cite{schmidref}.

\section{Množina aktivních proměnných}

Časovou složitost algoritmu pro převod regulárních výrazů se zpětnými referencemi na memory automat, je možné zlepšit několika způsoby. Jednou možností je omezení paměťových prvků, které se používají pro zpracování zpětných referencí.  

\begin{example}\label{ex:avd}
Buď $X=\{x, y\}$ množina proměnných, buď $\Sigma=\{a, b\} $ abeceda. Pro regex $\alpha = x \{a^\ast\} \ x \ ( y a \ y \{b^\ast\})^\ast \in RV_{\Sigma, X}$ podle algoritmu \texttt{simpleMemory} lze sestrojit memory automat se dvěma pamětmi. Je očividné, že jazyk $L(\alpha)$ lze přijat i $\mu$KA(1) tak, že se jediná paměť současně využije ke zpracování obou zpětných referencí. k~tomu však nestačí pouze substituovat proměnnou $y$ za $x$, protože se hodnota regexu $ x \{a^\ast\} \ x \ ( xa \ x \{b^\ast\})^\ast$ nerovná $L(\alpha)$. 
\end{example}

Vlastnost regexu, pomocí níž lze omezit počet pásek při převodu na TS, je definována na orientovaném grafu s~ohodnocenými hranami $\mathcal{H}(\alpha)$. Konstrukce tohoto grafu je popsána v~sekci \ref{sec:memory}.

\begin{definition}
Buď $\varphi \in \mathcal{N}(\alpha)$ kořen AST. Binární relace $\triangleright_{def} \subseteq X \times V$ a $\triangleright_{call} \subseteq v~\times X$ jsou definovány takto:
\begin{equation}\begin{split} x \triangleright_{def} \beta &\iff \text{v $\mathcal{H}(\alpha)$ existuje cesta }  (\varphi_{in}, e_1, \dots, e_n, \beta) \text{ taková, že } \\ &\bigg(\exists k~\in \{1, \dots, n\}\bigg) \bigg [ f(e_k)=[\,_x \ \bigg] \end{split}\end{equation}
\begin{equation}\begin{split} \beta \triangleright_{call} x &\iff \text{v $\mathcal{H}(\alpha)$ existuje cesta }  (\beta, e_1, \dots, e_n, \varphi_{out}) \text{ taková, že } \\ &\bigg(\exists k~\in \{1, \dots, n\}\bigg) \bigg [ f(e_k)=x \bigg ] \ \wedge \ \bigg(\forall i < k\bigg) \bigg[ f(e_i)\ne [\,_x \ \bigg] \end{split}\end{equation}
Pro $\beta \in V$ se množina $avs(\beta):=\{x \mid x \triangleright_{def} \beta \triangleright_{call} x\}$ nazývá množina aktivních proměnných. 
Parametr $avd$ (anglicky \emph{active variable degree}) pro regex $\alpha$ je definován takto: \cite{schmidref}
\begin{equation} avd(\alpha) := max\bigg\{|avs(\varphi)| \ \bigg | \ \varphi \in v~\ \wedge \bigg (
\exists e = (\gamma, \varphi) \in E \bigg ) \bigg [ f(e)=[\,_x \ \bigg] \bigg\}\end{equation}
\end{definition}

\begin{example} Nechť $\alpha = x\{a^\ast+b^\ast\} \ x \ (yb \ y \{b^\ast\})^\ast$ je regex z~$RV_{\{a, b\},\{x, y\}}$. Graf $\mathcal{H}(\alpha)$ je zobrazen na obrázku \ref{fig:avdgraph}. k~určení parametru \emph{avd} stačí najít aktivní proměnné pouze pro dva vrcholy $\gamma_{in}$, $\beta_{in}$ z~$V(\mathcal{H}(\alpha))$ (označeny červeně), kde $\gamma$, $\beta \in \mathcal{N}(a)$ jsou uzly reprezentující výraz uvnitř definice. Jelikož množina aktivních proměnných pro oba vrcholy je jednoprvková, $avd(\alpha) = 1$.
\end{example}

\begin{pozorovani}\label{obs:avd} Buď $x \in X$, a buď $G:=\Sigma\cup X\cup\{\varepsilon\}\cup\Gamma$. Nedeterministický konečný automat $\mathcal{M}_{x, \triangleright_{def}} = (\{q, p\}, G, \delta_0, q, \{p\})$ přijímá jazyk $L(\mathcal{M}_{x, \triangleright_{def}})={\{w \mid \ |w|_{[\,_x}\ge1\}}$. NKA $\mathcal{M}_{x, \triangleright_{call}}$ je pětice $(\{q, p, \varnothing\}, G, \delta_1, q, \{p\})$ a $L(\mathcal{M}_{x, \triangleright_{call}})= \{uxv \mid \ |u|_{[\,_x}=0\}$. Přechodové funkce $\delta_0$ a $\delta_1$ jsou znázorněny pomocí grafů přechodů na obrázku~\ref{fig:avd2}. 

Nechť $\alpha$ je regex z~$RV_{\Sigma, X}$ a $\mathcal{H}(\alpha)=(V,E,f)$. Nechť $\delta : v~\times G \rightarrow \wp(V)$ je zobrazení definované takto:
\begin{equation*}(\forall p, q \in V) (\forall x \in G) \ q \in \delta(p, x) \iff (p, q) \in E \ \wedge \ f((p,q))=x
\end{equation*}
Potom pro libovolné $\beta \in V$ a $x\in X$ platí následující tvrzení:
\begin{equation*} x \triangleright_{def} \beta \iff L(\mathcal{R}_0(\alpha))\cap L(\mathcal{M}_{x, \triangleright_{def}}) \ne \varnothing \end{equation*} \begin{equation*} \beta \triangleright_{call} x \iff L(\mathcal{R}_1(\alpha))\cap L(\mathcal{M}_{x, \triangleright_{call}}) \ne \varnothing, \end{equation*}
kde $\varphi$ je kořen AST reprezentujícího $\alpha$, $\mathcal{R}_0(\alpha)=(V, G, \delta, \varphi_{in}, \{\beta\})$ a $\mathcal{R}_1(\alpha)=(V, G, \delta, \beta, \{\varphi_{out}\})$.
$\mathcal{R}(\alpha) = (V, G, \delta, \varphi_{in}, \{\varphi_{out}\})$ je NKA přijímající referenční jazyk daný regexem $\alpha$. Potom jazyk přijímaný $\mathcal{R}_1(\alpha)$ (resp. $\mathcal{R}_0(\alpha)$) obsahuje podřetězce, které může přijat $\mathcal{R}(\alpha)$ s~počátečním (resp. jediným koncovým) stavem $\beta$. $\mathcal{M}_{x, \triangleright_{def}}$ přijímá všechny řetězce, v~nichž je alespoň jedna otevírací závorka definice proměnné $x$ a $\mathcal{M}_{x, \triangleright_{call}}$ přijímá všechny řetězce, v~nichž je alespoň jedna reference na $x$ a před danou referencí neexistuje žádná definice na tuto proměnnou. Průnik jazyků $L(\mathcal{R}_0(\alpha))\cap L(\mathcal{M}_{x, \triangleright_{def}})$ je prázdný jazyk, právě když v~$\mathcal{R}(\alpha)$ z~počátečního stavu do stavu $\beta$ neexistuje posloupnost přechodů, pomocí níž automat přečte řetězec obsahující otevírací závorku pro definici proměnné $x$ (toto odpovídá binární relaci $x \ntriangleright_{def} \beta$). Průnik jazyků $L(\mathcal{R}_1(\alpha))\cap L(\mathcal{M}_{x, \triangleright_{call}})$ není prázdný jazyk, právě když v~$\mathcal{R}(\alpha)$ z~počátečního stavu do stavu $\beta$ existuje posloupnost přechodů, pomocí níž automat přečte řetězec, v~němž existuje alespoň jedna reference na $x$ před nějakou definici ($\dots x \dots [\,_x \dots ]\,_x$), což odpovídá binární relaci $\beta \triangleright_{call} x$. \cite{schmidref}
\end{pozorovani}

\begin{figure}[ht] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
	\centering % centers the figure
	\begin{tikzpicture}[scale=0.8]
		\tikzstyle{every node}=[scale=0.8]
		\node[initial, state] (start) {$q$};
		\node[accepting, state, right= 2cm of start] (end) {$p$};
		\node[initial, state, right=2cm of end] (start2) {$q$};
		\node[state, below right=1cm and 1cm of start2] (non) {$\varnothing$};
		\node[below=0.5cm of start] (t1) {$\delta_0$:};
		\node[below=0.5cm of start2] (t1) {$\delta_1$:};
		\node[accepting, state, right= 2cm of start2] (end2) {$p$};
		\draw  	(start) edge[loop above] node[above]{$a \in G \setminus\{[\,_x\}$} (start)
				 (non) edge[loop below] node[below]{$a \in G$} (non)
				  	(end2) edge[loop above] node[above]{$a \in G$} (end2)
				(start) edge node[above]{$[\,_x$} (end)
				(end) edge[loop above] node[above]{$a \in G$} (end)
				(start2) edge[loop above] node[above]{$a \in G \setminus \{[\,_x , x\}$} (start2)
				(start2) edge node[right=0.2cm]{$[\,_x$} (non)
				(start2) edge node[above]{$x$} (end2)
				(end) edge[loop above] node[above]{$a \in G$} (end);
	
		
	\end{tikzpicture}
	\caption{Grafy přechodů automatů $\mathcal{M}_{x, \triangleright_{def}}$ a $\mathcal{M}_{x, \triangleright_{call}}$}
	\label{fig:avd2}
\end{figure}

Parametr $avd$ nám neformálně říká, že automat přijímající jazyk daný $\alpha$ musí v~nějakém kroku výpočtu mít vyhrazenou paměť alespoň pro $avd(\alpha)$ proměnných.

\begin{algorithm}
 \caption{Výpočet parametru $avd$}\label{alg:avdcomp}
    \SetKwInOut{Input}{Vstup}
    \SetKwInOut{Output}{Výstup}
	\DontPrintSemicolon
    \Input{$\alpha \in RV_{\Sigma, X}$} 
    \Output{$avd(\alpha)$}	
\SetAlgoLined

\SetKwFunction{Exec}{execTrans}
\SetKwProg{Def}{def}{}{}

	Nechť $\varphi$ je kořen AST reprezentujícího $\alpha$, $G\gets\Sigma\cup X\cup\{\varepsilon\}\cup\Gamma$\;
	Sestroj graf $\mathcal{H}(\alpha)=(V, E, f)$\;
	$\delta \ : \ v~\times G \rightarrow \wp(V)$\;
	($\forall p, q \in V$)($\forall a \in G$) $p \in \delta(q, a) \iff e=(q, p) \in E \ \wedge \ f(e)=a$\;
	$avd \gets 0$\;
	\For{$\beta \in V$}{
		\uIf{$ (\gamma, \beta) \in E \ \wedge \ f( (\gamma, \beta) ) = [\,_x$}{
			$avs(\beta) \gets \varnothing$\;
			\For{$x \in X$}{
				$\mathcal{R}_0(\alpha)=(V, G, \delta, \varphi_{in}, \{\beta\})$\;
				$\mathcal{R}_1(\alpha)=(V, G, \delta, \beta, \{\varphi_{out}\})$\;
				\uIf{$L(\mathcal{R}_0(\alpha))\cap L(\mathcal{M}_{x, \triangleright_{def}}) \ne \varnothing \ \wedge \ L(\mathcal{R}_1(\alpha))\cap L(\mathcal{M}_{x, \triangleright_{call}}) \ne \varnothing $} {$avs(\beta) \gets avs(\beta) \cup \{x\} $}
			}
				\lIf{$|avs(\beta)| > avd$} {$avd \gets |avs(\beta)|$}
		}
	}

\KwRet avd\;
\end{algorithm}

\begin{theorem}\label{avdcomp}Algoritmus \ref{alg:avdcomp} spočítá pro regex $\alpha \in RV_{\Sigma, X}$ parametr $avd$ v~čase $\mathcal{O}(|X|\cdot|\alpha|^2)$. \cite{schmidref}
\end{theorem}
Důkaz předchozí věty je podrobně uveden v~\cite[s. 7]{schmidref}. v~kroku 12 se dvakrát použije algoritmus pro skládání automatu \cite[s. 54--56]{sestakova} a pro dva výsledné NKA $\mathcal{M}_1$ a $\mathcal{M}_2$ pro průnik odpovídajících jazyků je potřeba ověřit, jestli nejsou přijímané jazyky $L(\mathcal{M}_1)$ a $L(\mathcal{M}_2)$ prázdné (neexistuje žádná posloupnost přechodů z~počáteční konfigurace do koncové).

\section{Algoritmus \texttt{avdMemory}}

V této sekci je popsán způsob, jak lze převést regex na ekvivalentní memory automat tak, že počet pamětí záleží pouze na parametru \emph{avd} tohoto regexu. 
Uvedený algoritmus byl převzat z~\cite[kapitola 3]{schmidref}.

Nechť $k=avd(\alpha)$, kde $\alpha$ je vstupní regex, a nechť je dána množina $\Gamma = \{x, ]\,_x, [\,_x \mid x \in var(\alpha)\}$. Jelikož parametr $avd$ může být menší než počet proměnných ve výrazu, výsledný automat bude fungovat tak, že jedna paměť je sdílena mezi více proměnnými. 

Množina stavů výsledného automatu $Q$ je vytvořena z~množiny vrcholů grafu $\mathcal{H}(\alpha)$ následovně:
\begin{itemize}
	\item Každý stav $q \in Q$ je dvojicí $(v, \langle i_0, \dots, i_{k-1}  \rangle)$, kde $v \in V(\mathcal{H}(\alpha))$ a ${i_j \in var(\alpha) \cup \{\bot\}}$ pro $\forall j \in \{0, \dots, k-1\}$. Posloupnost $ i_0, \dots, i_{k-1}$ se nazývá \emph{memory list}. Tato modifikace množiny stavů nám říká, že nachází-li se automat ve stavu $q$, $j$-tá paměť je vyhrazena pro proměnnou $x$, právě když $i_j = x$. Pokud je $j$-tá paměť volná, platí $i_j = \bot$.
	\item Počáteční stav automatu je $q_0 = (\varphi_{in}, \langle \bot, \dots, \bot \rangle)$, kde $\varphi$ je kořen AST pro $\alpha$.
	\item Množina koncových stavů $F \subseteq \{\varphi_{out}\} \times (var(\alpha) \cup \{\bot\})$ se skládá ze stavů, do nichž vede alespoň jeden přechod. 
\end{itemize}

Buď $q=(v, \langle i_0, \dots, i_{k-1} \rangle), p=(w, \langle j_0, \dots, j_{k-1} \rangle) \in Q$. Přechodová funkce je definována následovně.
\begin{enumerate}
	\item{\label{avd:call} Pro libovolnou hranu $p \in \delta(q, t)$ (kde ${t \in \Sigma \cup \{\varepsilon\} \cup \Gamma}$) a proměnnou $x \in X$ platí:	\begin{equation}\forall l \in \{0, \dots, k-1\} \big( w \ntriangleright_{call} x \implies j_l \ne x) \end{equation}
	Ve stavu $p$ by neměla být vyhrazena paměť pro proměnnou $x$, protože ze stavu $w$ lze přečíst pouze referenční slovo, v~němž bude před každou následující referencí existovat nová definice této proměnné (plyne z~definice relace $\triangleright_{call}$).
		}
	\item\label{rule2}{Pro $a \in \Sigma\cup\{\varepsilon\}$ 
			\begin{equation}
			p \in \delta(q, a) \iff (v, w) \in E(\mathcal{H}(\alpha)) \ \wedge \ f((v, w))=a
			\end{equation} a pro každé $l \in \{0, \dots, k-1\} \  j_l = i_l$, pokud $w \triangleright_{call} i_l$ (jinak $j_l = \bot$ podle pravidla \ref{avd:call}).
			
		Pro všechny přechody, při nichž automat neprovádí operace s~pamětí, seznam proměnných $i_0, \dots, i_k$ se jenom překopíruje ze stavu $q$ do $p$ (příp. se uvolní odpovídající paměť dle pravidla \ref{avd:call}). } 
 
	\item{\label{rule3}Pro $x \in X$ a $\varphi \in \{[\,_x, ]\,_x\}$
	 \begin{equation} p \in \delta(q, \varepsilon) \iff (v, w) \in E(\mathcal{H}(\alpha)) \ \wedge \ f((v, w))=\varphi \ \wedge \  w \ntriangleright_{call} x
	\end{equation}  a 
			pro každé $l \in \{0, \dots, k-1\} \  j_l = i_l$, pokud $w \triangleright_{call} i_l$ (jinak $j_l = \bot$ podle pravidla \ref{avd:call}).

Pokud ze stavu $w$ lze přečíst pouze referenční slovo, v~němž bude před každou následující referencí existovat nová definice této proměnné, není potřeba ani vyhrazovat paměť pro $x$.}
	\item{Pro $x \in X$ 
		\begin{equation}p \in \delta(q, \varepsilon) \iff (v, w) \in E(\mathcal{H}(\alpha)) \ \wedge \ f((v, w))= x \ \wedge \ (\nexists s) i_s = x
		\end{equation} a 
			pro každé $l \in \{0, \dots, k-1\} \  j_l = i_l$, pokud $w \triangleright_{call} i_l$ (jinak $j_l = \bot$ podle pravidla \ref{avd:call}).
	
	S $x$-přechodem ze stavu $q$ lze zacházet jako s~$\varepsilon$-přechodem, pokud v~$q$ není vyhrazena žádná paměť pro $x$.}
	\item{Pro $x \in X$
	 \begin{equation}\begin{split}&p \in \delta(q, s) \iff (v, w) \in E(\mathcal{H}(\alpha)) \ \wedge \ f((v, x))=\varphi \ \wedge \  (\exists s) i_s = x \\
						   &p \in \delta(q, ]\,_s) \iff (v, w) \in E(\mathcal{H}(\alpha)) \ \wedge \ f((v, ]\,_x))=\varphi \ \wedge \  (\exists s) i_s = x \\
	\end{split}\end{equation}  a 
			pro každé $l \in \{0, \dots, k-1\} \  j_l = i_l$, pokud $w \triangleright_{call} i_l$ (jinak $j_l = \bot$ podle pravidla \ref{avd:call}).
Automat ze stavu $q$ (v tomto stavu $s$-tá paměť je vyhrazena pro $x$) čte referenci nebo \uv{uzavírá} paměť vyhrazenou pro $x$. }
	\item\label{rule7}{Pro $x \in X$
		\begin{equation}\label{tvrzA}\begin{split} p \in \delta(q, [\,_p) \iff &(v, w) \in E(\mathcal{H}(\alpha)) \ \wedge \ f((v, w))= [\,_x \ \wedge \\  &(\exists p) (i_p = \bot \ \wedge \ j_p=x)\end{split}\end{equation}
		\begin{equation}\begin{split}
		 p \in \delta(q, [\,_p) \iff &(v, w) \in E(\mathcal{H}(\alpha)) \ \wedge \ f((v, w))= [\,_x \ \wedge \\ &(\exists p) (i_p = x \ \wedge \ j_p=x) 
		\end{split}\end{equation} a 
			pro každé $l \in \{0, \dots, k-1\} \  j_l = i_l$, pokud $w \triangleright_{call} i_l$ (jinak $j_l = \bot$ podle pravidla \ref{avd:call}).

		Pokud ve stavu $q$ je vyhrazena paměť pro $x$, automat při čtení definice ponechá \emph{memory list} beze změn, jinak najde nějakou volnou paměť $p$ a nastaví $s_p \gets \texttt{O}$ (tvrzení \ref{tvrzA}).
	
	}
	\end{enumerate}
	Výsledný automat $\mathcal{M} = (Q, \Sigma, \delta, q_0, F)$ je $\mu KA(k)$, kde $k = avd(\alpha)$.
	Příklad převodu regexu na memory automat pomocí uvedeného algoritmu lze najít v~příloze \ref{ukazka:avd}.

	Algoritmus, který přijme na vstup AST pro regex $\alpha$ a vstupní slovo $w$, zkonstruuje ekvivalentní memory automat $\mathcal{M}$ pomocí výše popsaného algoritmu a nasimuluje výpočet $\mathcal{M}$ pro vstup $w$, se v~této práci nazývá \texttt{avdMemory}.
	\begin{theorem}
		Časová složitost \texttt{avdMemory} je $\mathcal{O}(|X|^k\cdot|w|^{k+1}\cdot|\alpha|^2)$, kde $k = avd(\alpha)$.
	\end{theorem}
	\begin{proof}
		Konstrukce memory automatu se skládá ze tří části: výpočet $avd$, konstrukce grafu $\mathcal{H}(a)$ a vytvoření stavů a přechodů pomocí výše popsaných pravidel. Výpočet parametru $avd$ spotřebuje čas $\mathcal{O}(|X|\cdot|\alpha|^2)$ (věta \ref{avdcomp}). Konstrukce grafu $\mathcal{H}(\alpha)$ spotřebuje čas $\mathcal{O}(|\alpha|)$ \cite[lemma~3]{schmidref}. Pro každý vrchol z~$V(\mathcal{H}(\alpha))$ se vytvoří $\mathcal{O}(|X|^k)$ stavů, kde $k = avd(\alpha)$, a pro každou hranu se do přechodové funkce $\delta$ přidá $\mathcal{O}(k)$ přechodů (pravidlo \ref{rule7}). Jelikož počet hran a vrcholů v~$\mathcal{H}(\alpha)$ je $\mathcal{O}(|\alpha|)$ (plyne z~definice grafu), celkem převod regexu na memory automat potrvá $\mathcal{O}(|X|\cdot|\alpha|^2 + |\alpha|\cdot(k+|X|^k)) = \mathcal{O}(|X|^k\cdot|\alpha|^2)$.
	
	Simulace výsledného automatu je procházení grafem konfigurací. Celkem výpočet memory automatu $\mathcal{M}$ pro vstup $w$ spotřebuje čas ${\mathcal{O}(|Q|\cdot|w|^{k+1})} = {\mathcal{O}(|\alpha|\cdot|X|^k\cdot|w|^{k+1})}$ \cite[lemma 3]{schmidref}.
	\end{proof}

	
\chapter{Realizace}
Pro implementaci byl autorem zvolen programovací jazyk C++. Bylo rozhodnuto realizovat tři algoritmy pro zpracování regexů: \texttt{simpleTM}, \texttt{simpleMemory} a \texttt{avdMemory}. v~následujících sekcích jsou popsány implementace jednotlivých částí prostředku pro práci s~regexy.

\section{Implementace lexeru a parseru}
Zdrojové soubory \texttt{lexer.h} a \texttt{lexer.cpp} obsahují realizaci lexikálního analyzátoru. Lexer vytváří pro parser tokeny, které jsou definovány pomocí výčtového typu \texttt{Token}. Jako promenné lexer rozeznává latinské kapitálky. Abeceda regexu je omezena na 27 malých písmen latinské abecedy. Pro jednoduchost se používají symboly \verb|?| pro $\varepsilon$ a \verb|0| pro prázdný regulární výraz. Například \verb|X{a*+?}X| je potom zápis regexu $x\{a^\ast+\varepsilon\} \ x$.
Všimněte si, že se pro lexer používá objekt typu \textbf{istringstream}, do něhož nejprve je zapsán textový řetězec reprezentující vstupní regex.

Zavoláním metody \texttt{getToken()} dojde k~načtení tokenu, jehož hodnota se uloží do proměnné \texttt{val}. 

\begin{figure}[ht]
	\begin{verbatim}
// A' -> + A | eps
unique_ptr<NodeAST> ParseARest(unique_ptr<NodeAST> left) {
    if (m_CurTok == tokenUnion) {
        getNextToken();
        auto right = move(ParseA());
        return make_unique<UnionAST>(move(left), move(right));
    } else if (m_CurTok == tokenEOF || m_CurTok == ')' 
								|| m_CurTok == '}') {
        return move(left);
    } else {
        ExpandError("A'", (Token) m_CurTok);
        return nullptr;
    }
}
	\end{verbatim}
	\caption{Funkce z~metody rekurzivního sestupu pro neterminál $A^\prime$}\label{source:parser}
\end{figure}

Parser dostává na vstup tokeny z~lexeru (metoda \texttt{getNextToken()}) a vytváří vnitřní reprezentaci regexu. Realizaci parseru lze najít ve zdrojových souborech \texttt{parser.h} a \texttt{parser.cpp}. Překlad definovaný LL(1) atributovou gramatikou z~sekce \ref{sec:semantic} je realizován pomocí tzv. \emph{metody rekurzivního sestupu} s~parametry. Například pro neterminál $A^\prime$ je vytvořena funkce \texttt{ParseARest} (viz obrázek \ref{source:parser}), jejíž vstupní parametr \texttt{left} odpovídá dědičnému atributu $dnode$. Výstupní parametr odpovídá syntetizovanému atributu $snode$. Hodnoty obou dvou atributů jsou ukazatele na vytvořené abstraktní syntaktické stromy, které jsou realizovány pomocí základní třídy \texttt{NodeAST} a odvozených tříd. Metoda \texttt{ExpandError} je volána, pokud dojde k~chybě při expanzi. Vznikne-li chyba při srovnání, metoda \texttt{MatchError} vypíše odpovídající chybovou zprávu na standardní výstup.   

Dále následuje popis jednotlivých tříd, které jsou definovány v~ \texttt{ast.h} a \texttt{ast.cpp}.
\begin{itemize}
	\item{Abstraktní třída \texttt{NodeAST} reprezentuje uzel syntaktického stromu. Tato třída obsahuje abstraktní metody \texttt{constructTM} a \texttt{constructAvdFA}, jež se používají při konstrukci TS a memory automatu (viz sekce~\ref{sec:implTM}--\ref{sec:implAvd}).} 
	\item{Třída \texttt{AtomAST} definuje uzel stromu reprezentující elementární regulární výraz. Jediným atributem je ASCII hodnota znaku (\texttt{m\_Val}).}  
	\item{Pomocí třídy \texttt{ConcatenationAST} (resp. \texttt{UnionAST}) je definován uzel reprezentující zřetězení (resp. sjednocení) dvou výrazu. Hodnoty atributů \texttt{m\_LHS} a \texttt{m\_RHS} obsahují ukazatele na uzly levého a pravého podstromu. Analogicky atribut \texttt{m\_Expr} třídy \texttt{IterationAST} označuje uzel potomka.}
	\item{Od třídy \texttt{VarAST} jsou odvozeny třídy \texttt{DefinitionAST} (uzel reprezentující definici proměnné) a \texttt{BackRefAST} (uzel reprezentující zpětnou referenci). Metoda \texttt{getVar} vrátí hodnotu atributu \texttt{m\_Var} (název proměnné). Atribut \texttt{m\_Expr} třídy \texttt{DefinitionAST} obsahuje ukazatel na uzel podstromu.}
\end{itemize}

\section{Reprezentace vícepáskového TS}
Způsob, jakým je automat reprezentován, byl převzat z~\cite{ndtmsim}. 

Zdrojové soubory \texttt{tape.h}, \texttt{tape.cpp} obsahují realizaci pásky TS pomocí třídy \texttt{Tape}. Tato třída definuje atributy \texttt{m\_Head} (pozice čtecí hlavy) a \texttt{m\_Cells} (obsah pásky). Typ pohybu čtecí hlavy je definován pomocí výčtového typu \texttt{ShiftType} (názvy ve výčtu jsou \texttt{left, noShift} a \texttt{right}). Posuv čtecí hlavy se provede zavoláním \texttt{moveHead} se vstupním parametrem typu \texttt{ShiftType}. Metoda \texttt{readSymbol} vrátí znak, na něhož ukazuje čtecí hlava. Zápis znaku na pásku je realizován pomocí metody \texttt{writeSymbol(char)}. 

\texttt{Automaton} (\texttt{automaton.h}) je šablonová abstraktní třída se šablonovým parametrem \texttt{T} (datový typ pro stav), ze které jsou odvozené třídy \texttt{NDTM} a \texttt{AvdFA}. Tato třída definuje následující atributy: 
\begin{itemize} 
	\item{\texttt{m\_InitialState : T} je počáteční stav automatu,}
	\item{\texttt{m\_FinalStates : set<T>} je množina koncových stavů,}
	\item{\texttt{m\_CurState : T} je aktuální stav,}
	\item{\texttt{m\_StateCnt : int} je počet stavů,}
	\item{\texttt{m\_Input : set<char>} je vstupní abeceda.}
\end{itemize}
Pro simulátor TS stavy automatu jsou reprezentovány celými čísly. Přidání nového stavu odpovídá inkrementaci proměnné \texttt{m\_StateCnt}. Číslo nového stavu odpovídá hodnotě \texttt{m\_StateCnt} před inkrementací.

Třída \texttt{NDTM} reprezentuje vícepáskový nedeterministický TS. Přechodová funkce automatu je reprezentována jako mapa, kde klíčem je pár $(q, w)$ ($q$ je stav automatu a $w$ jsou symboly, na něž ukazují čtecí hlavy pásek). Prvkem mapy je vektor párů $(q, o)$, kde $o$ označuje operace prováděny s~odpovídající páskou ($o = (c, shift)$, kde c je symbol, který se má zapsat, a $shift$ je typ pohybu hlavy). Taková reprezentace přechodové funkce byla zvolena z~důvodu co největší podobnosti s~formální definicí. Mezi atributy také patří \texttt{m\_Tapes} (vektor pásek automatu) a \texttt{m\_Blank} (blank symbol). Zavoláním metody \texttt{addTransition} se do přechodové funkce přídá přechod, který odpovídá vstupním parametrům.

Metoda \texttt{initialize(w : string)} nastaví počáteční konfiguraci pro řetězec~\texttt{w} tak, že zavolá \texttt{loadTape}, která inicializuje obsah pracovních pásek hodnotou $B^{|w|+2}$, kde $B$ je blank symbol TS, a nastaví pozice čtecích hlav na~$1$. Po volání předchozí metody obsah vstupní pásky bude odpovídat řetězci $BwB$. 

Výpočet TS je realizován metodou \texttt{accepts()} (viz obrázek \ref{code:accepts}), která vrátí \texttt{true}, pokud existuje posloupnost přechodů z~aktuální konfigurace do nějaké koncové. Nejprve je ověřeno, jestli se aktuální konfigurace už předtím ve výpočtu vyskytla (\texttt{hasCycle()}). Pokud ne, konfigurace pásek pro aktuální stav se uloží do paměti konfigurací (atribut \texttt{m\_ConfigurationsMemory}). Pokud ano, je potřeba výpočet pro tuto větev ukončit a vrátit \texttt{false}, jinak se automat zacyklí (viz příklad \ref{ex:cycle}). Po kontrole opakování konfigurací se pro každý možný přechod z~aktuální konfigurace vytvoří hluboká kopie automatu (\texttt{clone()}), pro vytvořenou kopii se provede odpovídající přechod (\texttt{execTransition()}) a zavolá se na ni metoda \texttt{accepts()}. Pokud ani jedno z~volání \texttt{accepts} nevrátí \texttt{true}, zjistí se, není-li aktuální konfigurace koncová. 

\begin{figure}[ht]
	\begin{verbatim}

bool accepts() {
    auto trans = m_Transitions[make_pair(m_CurState, 
							this->readSymbols())];
    if (this->checkCycle()) return false;
    for (int i = 0; i < trans.size(); i++) {
        auto tm = this->clone();
        tm->execTransition(trans[i]);
        if (tm->accepts()) return true;
    }
    return m_Tapes[0]->isEmpty() && 
	m_FinalStates.find(m_CurState) != m_FinalStates.end();
}
	\end{verbatim}
	\caption{Definice metody \texttt{accepts()} z~\texttt{ndtm.cpp}}\label{code:accepts}
\end{figure}


\section{Implementace algoritmu \texttt{simpleTM}}\label{sec:implTM}
Programovou realizaci prostředku pro práci s~regexy (anglicky \emph{regex matcher}) lze najít ve zdrojových souborech \texttt{matcher.h} a \texttt{mather.cpp}. Ve funkci \texttt{main} se vytvoří instance parseru a simulátoru TS s~počátečním a koncovým stavem a zavolá se konstruktor třídy \texttt{Matcher} se dvěma parametry \texttt{parser} (ukazatel na parser) a \texttt{option = "0"} (volba algoritmu). Metoda \texttt{ParseA()} vrátí ukazatel na kořen AST pro vstupní regex (\texttt{m\_Root}). Počet pásek automatu se nastaví na počet proměnných, které parser byl schopen rozpoznat, zvětšený o jednu. Přidání stavů a přechodů se do instance třídy \texttt{NDTM} provede zavoláním na ukazatel na \texttt{m\_Root} virtuální metody \texttt{constructTM} (viz deklaraci v~\texttt{ast.h}), která bude očekávat následující parametry:
\begin{itemize}
	\item{\texttt{tm} je ukazatel na TS,}
	\item{\texttt{tapes} je reference na \texttt{vector<bool>}, odpovídá tabulce $T[1,\dots,k]$ v~algoritmu \ref{alg:turing}, }
	\item{\texttt{memory} je reference na \texttt{map<char, int>}, odpovídá zobrazení $num$,}
	\item{\texttt{start} je počáteční stav pro uzel,}
	\item{\texttt{end} je koncový stav pro uzel.}
\end{itemize}
Každá z~tříd odvozených od \texttt{NodeAST} implementuje \texttt{constructTM} takovým způsobem, aby implementace této metody odpovídala funkci \texttt{buildTM} z~algoritmu \texttt{simpleTM}. 

Definice metody \texttt{match} se vstupním parametrem \texttt{w} se skládá z~nastavení počáteční konfigurace simulátoru (pomocí \texttt{initialize(w)}) a simulace výpočtu  metodou \texttt{accepts}.
\section{Implementace algoritmů \texttt{simpleMemory} a \texttt{avdMemory}}\label{sec:implAvd}
Analogicky jako v~předchozí sekci se z~funkce \text{main} zavolá konstruktor \texttt{Matcher} s~parametry \texttt{parser} a \texttt{option} (volba algoritmu: \texttt{"1"} pro \texttt{simpleMemory} a \texttt{"2"} pro \texttt{avdMemory}). 

Vytvoří se instance třídy \texttt{AvdFA} (reprezentuje NKA, přijímající referenční jazyk vstupního regexu). Konstrukce daného automatu se provede zavoláním na ukazatel na \texttt{m\_Root} virtuální metody \texttt{constructAvdFA} (viz deklaraci v~\texttt{ast.h}), která bude očekávat následující parametry:
\begin{itemize}
	\item{\texttt{automaton} je ukazatel na NKA,}
	\item{\texttt{avd} je reference na \texttt{vector<int>} (vektor, do něhož se uloží počáteční stavy pro uzly reprezentující výraz uvnitř definice: pro tyto stavy je potřeba spočítat množinu aktivních proměnných při volbě algoritmu \texttt{avdMemory}),}
	\item{\texttt{in} je počáteční stav pro uzel,}
	\item{\texttt{out} je koncový stav pro uzel.}	
\end{itemize} 

Výsledný $\mu$KA je reprezentován pomocí šablonové třídy \texttt{MemoryAutomaton}. Tato třída definuje následující atributy: 
\begin{itemize} 
	\item{\texttt{m\_Tape : string} je vstupní páska,}
	\item{\texttt{m\_Pos : int} je pozice čtecí hlavy,}
	\item{\texttt{m\_Memory : vector<pair<bool, string>>} je paměť automatu (stav a obsah paměti),}
	\item{\texttt{m\_CurState : T} je aktuální stav,}
	\item{\texttt{m\_StateCnt :  map<T, vector<pair<string, T>>>} reprezentuje přechodovou funkci automatu,}
	\item{\texttt{m\_ConfigurationMemory : map<T, pair<int, vector<string>>>} je paměť konfigurací (pomocí této paměti lze zabránit vzniku cyklů v~memory automatu).}
\end{itemize}

Při volbě \texttt{"1"} se program zavoláním metody \texttt{simpleMemory} (se vstupním parametrem \texttt{vars}, který odpovídá množině proměnných regexu) na instanci třídy \texttt{AvdFA} vytvoří objekt \texttt{MemoryAutomaton} (stavy jsou opět reprezentovány datovým typem \texttt{int}).

Při volbě \texttt{"2"} program vypočte parametr $avd$ regexu.

Pomocí metod \texttt{constructR0} a \texttt{constructR1} je implementován algoritmus pro skládání automatu (viz krok 12 algoritmu \ref{alg:avdcomp}). Metoda \texttt{constructR0} se vstupními parametry \texttt{state} a \texttt{var} vrátí ukazatel na automat přijímající jazyk $L(\mathcal{R}_0(\alpha))\cap L(\mathcal{M}_{x, \triangleright_{def}})$, kde $\mathcal{R}_0(\alpha)$ je NKA $\mathcal{R}$ přijímající referenční jazyk $\alpha$ s~jediným koncovým stavem \texttt{state}, a \texttt{constructR1} vrátí ukazatel na automat přijímající $L(\mathcal{R}_1(\alpha))\cap L(\mathcal{M}_{x, \triangleright_{call}})$, kde $\mathcal{R}_1(\alpha)$ je $\mathcal{R}$ s~počátečním stavem \texttt{state}. Virtuální metoda \texttt{accepts} v~třídě \texttt{AvdFA} vrací \texttt{true}, pokud automat přijímá neprázdný jazyk. Jedná se o prohledávání grafu konfigurací automatu pomocí algoritmu DFS.

Pomocí předchozích metod se vypočte mohutnost množiny aktivních proměnných pro každý stav z~vektoru \texttt{avd}. 

Parametr $avd$ program předá jako vstupní parametr metodě \texttt{avdMemory}. Tato metoda implementuje algoritmus pro převod regexu na memory automat, kde počet pamětí je roven  $avd(\alpha)$. Výstupem funkce je instance třídy \texttt{MemoryAutomaton} se šablonovým parametrem typu \texttt{MemoryState}, který reprezentuje stav memory automatu rozšířený o \emph{memory list}.

\chapter{Testování}

Testování proběhlo ve virtuálním stroji s~operačním systémem Ubuntu 19.10 v~konfiguraci s~2 GB operační paměti a dvěma procesory. 
Hostitelský stroj měl šestijádrový procesor Intel Core i7-8750H @ 2.20 GHz a 16~GB RAM.

Spustitelný soubor \texttt{regexmatcher} se vytvoří příkazem \texttt{make compile}. Při kompilaci je použít kompilátor GNU C++ verze 9.2.1, který se spustí s~následujícímu přepínači: \texttt{-std=c++14 -Wall -pedantic -Wno-long-long -O0 -ggdb}. Pro generování dokumentace ve formátu HTML zadejte příkaz \texttt{make doc}.

Program lze spustit z~příkazové řádky, kde vstupní regex je druhý parametr. Vstupní řetězec je zapsán jako třetí argument spouštěného programu. Prvním parametrem je volba algoritmu. Například zadáním příkazu $$\texttt{./regexmatcher 0 X\{a+b\}X+? bbaa}$$ program vytvoří simulátor TS příjímajícího ${L(x\{a+b\}\ x+\varepsilon)}$ pomocí algoritmu \texttt{simpleTM}, provede simulaci výpočtu pro vstupní slovo $bbaa$ a vytiskne na standardní výstup \texttt{yes}, pokud vstupní řetězec odpovídá regexu (jinak vytiskne \texttt{no}).

\section{Vytvoření testových souborů}
Pro účely testování bylo vytvořeno šest testovacích sad (vstup a referenční výstup). Soubor \texttt{<název\_sady>.in} má $2n$ řádků a obsahuje celkem $n$ testů. Každý test se skládá ze dvou řádků: na prvním je zapsán regex, na druhém je vstupní slovo. \texttt{<název\_sady>.out} se skládá z~$n$ řádků, kde na $i$-tém řádku je referenční řešení pro $i$-tý test. Následuje popis jednotlivých testovacích sad:
\begin{itemize}
	\item{První sada \texttt{simple} obsahuje 20 testů. Regexy z~této sady jsou omezeny dvouprvkovou abecedou $\{a, b\}$ a jednoprvkovou množinou proměnných $\{x\}$.}
	\item{\texttt{simpleReg} obsahuje 20 testů. Regexy z~této sady jsou omezeny stejným způsobem jako v~sadě \texttt{simple}. Vstupní slovo v~testech je většinou delší. Tyto testy mohou zpomalit hlavně simulátor TS nebo memory automatu kvůli většímu počtu volání funkce \texttt{accepts}. }
	\item{Sada s~názvem \texttt{nVar} se skládá z~10 testů. Regexy z~této sady jsou omezeny dvouprvkovou abecedou $\{a, b\}$, přičemž parametr $avd$ daných regexů je maximálně 2. Pomocí těchto testů lze porovnat matcher založený na algoritmech \texttt{simpleMemory} (resp. \texttt{avdMemory}) s~implementací \texttt{simpleTM}.}
	\item{Testovací soubor \texttt{nSigma.in} obsahuje 10 testů. Regexy z~tohoto souboru jsou omezeny jednoprvkovou množinou proměnných $\{x\}$. Počet různých symbolů abecedy $p$ v~libovolném regexu je větší než 5. Takové regexy by mohly zpomalit konstrukci TS hlavně kvůli tzv. \emph{$\varepsilon$-přechodům}, kde se do přechodové funkce přidá $\mathcal{O}(|\alpha|\cdot|p|^{k})$ přechodů ($k$ je počet pásek). }
	\item{Testovací sada s~názvem \texttt{hard} se skládá z~$12$ testů. Regexy z~tohoto souboru mají větší délku a obsahují velký počet proměnných a symbolů abecedy. Vstupní slova jsou také v~těchto testech delší. Účelem dané sady je co nejvíc zatížit každou část prostředku pro zpracování regexů.}
	\item{Poslední sada \texttt{avd} je určena pro porovnání algoritmů \texttt{simpleMemory} a \texttt{avdMemory}. Regexy z~této sady mají parametr $avd$ menší nebo roven 2 a vstupní slova jsou mnohem delší než v~ostatních sadách.}
\end{itemize}

Pro spuštění testů, které ověří správnost implementací, zadejte \texttt{./test.sh <název\_sady>}.  

\section{Porovnání s~nástroji pro práci s~regulárními výrazy}
 Pro porovnání byly zvoleny tyto nástroje:
 \begin{itemize}
	\item{program \emph{grep} verze 3.3, který používá syntaxi regexů odpovídající standardu POSIX ERE. Všimněte si, že tato utilita nepodporuje ani celou množinu semiregexů (konkrétně semiregexy, v~nichž se zpětná reference na $i$-tou závorku nemůže nacházet před $i$-tou uzavírací závorkou). Navíc existuje omezení na počet číslovaných skupin zachycení (nemůže být větší než 9).}
	\item{\emph{Perl} verze 5.28.1, kde regulární výrazy odpovídají standardu PCRE. Na regexy v~jazyce Perl nejsou kladena omezení na počet proměnných. Perl však nepodporuje například regexy, v~nichž se opakují závorkové skupiny se stejným jménem (např. \texttt{(?<A>a*)(?<A>b*)\textbackslash g\{A\}}). Problém také tvoří nedefinované reference na proměnné (např. řetězec \texttt{aa} neodpovídá regexu \texttt{((?<A>a)|(?<B>b))\textbackslash g\{A\}\textbackslash g\{B\}}). }
 \end{itemize}

Pro testovací sady je vytvořen vstupní soubor, v~němž vstupní regexy odpovídají syntaxi použité v~nástroji, ale mají tentýž sémanticky význam jako regexy v~původním vstupním souboru. Pro některé regexy nebylo možné najít ekvivalentní výraz v~požadované notaci.

Pro měření času je použít příkaz \texttt{time}. Pomocí skriptu \texttt{testTime.sh} (nebo příkazem \texttt{make testTime <název\_sady>}) lze porovnat čas běhu vytvořeného prostředku pro práci s~regexy s~konkurenčními nástroji pro danou sadu. 
Naměřené časy (\texttt{real time}) pro jednotlivé testovací sady a nástroje pro práci s~regexy jsou zobrazeny v~tabulce~\ref{tab:time}. 

\begin{table}
\begin{center}
\begin{tabular}{l||r|r|r|r|r}
 & 		\texttt{simpleTM}		 & \texttt{simpleMemory}   & 	\texttt{avdMemory}			&   	\texttt{grep}		      & \texttt{Perl} \\ \hline \hline
 \texttt{simple} &               0,141      & 0,063  &   0,098                 &       0,031              &  0,036  \\ \hline
 \texttt{simpleReg} &           6,348      &  0,568 &  0,69                  &   --\footnote[1]              & 0,014  \\ \hline
 \texttt{nVar} &             --\footnote[7]          &   2,137    &      45,733          &                --\footnotemark[1]      &  --\footnotemark[1]\\ \hline
 \texttt{nSigma}&            1,687           & 0,11     &        0,273       &             0,017         &   0,023\\ \hline
 \texttt{avd}& --\footnotemark[7] & 1,677 & 1,572 & --\footnotemark[1] & --\footnotemark[1] \\ \hline
\texttt{hard}&             --\footnotemark[7]      & 1,831 &          16,392         &                --\footnotemark[1]     &  --\footnotemark[1] \\ \hline
\end{tabular}
\end{center}
\caption{\label{tab:time} Naměřené časy pro implementace autora a konkurenční implementace pro jednotlivé sady v~sekundách}
\end{table}
\footnotetext[1]{pro některé regexy neexistuje ekvivalent v~daném nástroji (resp. ekvivalentní výraz je mnohem složitější)}
\footnotetext[7]{testy trvají řádově desítky minut}

\section{Zhodnocení výsledků testování}
Implementace autora jsou výrazně pomalejší než implementace v~jazyce Perl pro testovací sadu \texttt{simpleReg}, kde vstupní řetězec je mnohem delší než regex. Je toto ovlivněno hlavně neefektivním sekvenčním algoritmem pro simulaci vícepáskového TS a memory automatu. Oproti programu \emph{grep} implementace \texttt{simpleTM}, \texttt{simpleMemory} a \texttt{avdMemory} podporují například regexy s~definicemi a referencemi v~iteraci (například \texttt{(X\{a+b*\}X)*} z~testovací sady \texttt{simpleReg}). z~tabulky lze z~jistotou tvrdit, že obě konkurenční implementace kladou poměrně striktní omezení na zpětné odkazy a zachytávající skupiny.

Co se týče porovnání implementací autora, \texttt{simpleMemory} je efektivnější pro většinu testovacích sad kromě \texttt{avd}. Pokud na vstupu je delší řetězec a kratší regex s~parametrem $avd$ menším než 3 (což odpovídá specifikaci testovací sady \texttt{avd}), algoritmus \texttt{avdMemory} může být efektivnější (i když při konstrukci je potřeba spočítat $avd$ regexu a výsledný memory automat má větší počet přechodů a stavů). Naopak algoritmus \texttt{simpleTM} se ve srovnání s~ostatními implementacemi ukázal mnohem pomalejší: testy z~sad \texttt{nVar}, \texttt{hard} a \texttt{avd} mohou trvat řádově desítky minut.

\begin{conclusion}
Cílem teoretické části této práce bylo zformulovat problém zpracování regexů a podrobně popsat algoritmy pro zpracování těchto výrazů.  
Mezi přínosy práce lze řadit důkaz věty o NP-úplnosti problému založený na pojmu referenčního slova.

Praktická část této práce si kladla za cíl implementovat a otestovat jeden z~algoritmů. Výsledkem práce je funkční implementace dvou algoritmů založených na konstrukci memory automatu (\texttt{simpleMemory} a \texttt{avdMemory}) a jednoho na konstrukci TS (\texttt{simpleTM}). z~výsledků měření lze považovat algoritmus \texttt{simpleMemory} za efektivnější. Oproti konkurenčním implementacím vypracovaná konzolová aplikace neklade striktní omezení na vstupní regex.  Autorem implementovaný prostředek pro zpracování regexů se však ve srovnání s~existujícími nástroji pro práci s~regulárními výrazy ukázal méně výkonný na třech z~šesti vytvořených testovacích sad.

V budoucnosti by bylo zajímavé paralelizovat simulaci výpočtu TS a memory automatu, která z~výsledků testování nejvíc zpomalovala běh celé implementace. Větší pozornost by mohla být věnována také parametrizovanému problému zpracování regexů.  

\end{conclusion}

\bibliographystyle{csn690}
\bibliography{mybibliographyfile}

\appendix

\chapter{Ukázka fungování algoritmů pro zpracování regexů}
Nechť $\Sigma = \{a, b\}$ je abeceda a $X = \{x, y\}$ je množina proměnných. Regex $\alpha = y\{b^\ast\} \ x\{a^\ast\} \ b \ x$ je validní řetězec z~množiny $RV_{\Sigma, X}$. Abstraktní syntaktický strom pro $\alpha$ je zobrazen na obrázku \ref{fig:ast1}.

\begin{figure}[h]
\centering

\begin{tikzpicture}[scale=0.8, edge from parent path={(\tikzparentnode.south) .. controls +(0,-0.4) and +(0,0.4).. (\tikzchildnode.north)}, -]
	\tikzstyle{every node}=[fill=gray!30, rounded corners, scale=0.8]
	\tikzstyle{level 1}=[sibling distance=6cm]\tikzstyle{level 2}=[sibling distance=4cm]\tikzstyle{level 3}=[sibling distance=2cm]
	\node {$\cdot$}
		[level distance=1cm]
		child {node {$y\{\}$}
			child {node {$\ast$}
				child {node {b}}
			}
		}
		child {node {$\cdot$}
			child {node {$x\{\}$}
				child {node {$\ast$}
					child {node {a}}
				}
			}
			child {node {$\cdot$}
				child {node {b}}
				child {node {$y\{\}$}
					child {node {$\ast$}
						child {node {a}}
					}
				}
			}
		};
\end{tikzpicture}
\caption{AST pro regex  $y\{b^\ast\} \ x\{a^\ast\} \ b \ x$}\label{fig:ast1}
\end{figure}
\section{Ukázka převodu regexu na vícepáskový TS}\label{ukazka:simpletm}
Počet proměnných ve výrazu je roven 2. Zobrazení $num$ lze definovat například takto:
$num(x) := 1; \ num(y) := 2$, což znamená, že první (resp. druhá) páska je vyhrazena pro proměnnou $x$ (resp. $y$). Výstupní $TS(3)$ je sedmici $$(Q, \{a, b, B\}, B, \{a, b\}, \delta, q_0, \{q_1\}),$$ kde $Q$ je množina stavu a $\delta$ je znázorněna pomocí grafu přechodů na obrázku~\ref{fig:examplets}. Pro přehlednost některé hrany jsou označeny symboly $\varepsilon$. Například hrana, která je označená řetězcem $\big \langle a, B, 1 \big\rangle, \varepsilon, \big \langle a, a, 1 \big\rangle$, znamená přechod, při kterém automat přečte a zapíše tentýž symbol na první pásku a čtecí hlava této pásky zůstane na místě (konfigurace první pásky se nezmění). 

\begin{figure}[ht] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
	\centering % centers the figure
	\begin{tikzpicture}[scale=0.5]
		\tikzstyle{every node}=[scale=0.5]
		\node[initial, state] (q0) {$q_{0}$};
		\node[state, right=8mm of q0] (q2) {};
		\node[state, above right=9mm and 4mm of q2] (q3) {};
		\node[state, above right=7mm and 12mm of q3] (q5) {};
		\node[state, above right=7mm and 2mm of q5] (q6) {};
		\node[state, right=10mm of q6] (q7) {};
		\node[state, below right=7mm and 2mm of q7] (q8) {};
		\node[state, below right=7mm and 3mm of q8] (q9) {};
		\node[state, left=7mm of q9] (q10) {};
		\node[state, left =7mm of q10] (q4) {};
		\node[state, below=4mm of q10] (q11) {};
		\node[state, below right=4mm and 9mm of q11] (q12) {};
		\node[state, below right=5mm and 10mm of q12] (q14) {};
		\node[state, below left=2mm and 7mm of q14] (q15) {};
		\node[state, below=10mm of q15] (q16) {};
		\node[state, below right=2mm and 7mm of q16] (q17) {};
		\node[state, below =8mm of q17] (q28) {};
		\node[state, left =8mm of q28] (q29) {};
		\node[state, above=5mm of q29] (q18) {};
		\node[state, left=8mm of q18] (q19) {};
		\node[state, left=8mm of q19] (q20) {};
		\node[state, above left=13mm and 2mm of q20] (q21) {};
		\node[state, below left=13mm and 2mm of q21] (q22) {};
		\node[state, left=8mm of q22] (q23) {};
		\node[state, above=12mm of q23] (q24) {};
		\node[state, left=10mm of q24] (q25) {};
		\node[state, above left=12mm and 4mm of q25] (q26) {};
		\node[state, below=12mm of q26] (q27) {};
		\node[accepting, state, below=10mm of q27] (q1) {$q_{1}$};

		\draw (q0) edge node[above]{$\varepsilon, \varepsilon, \varepsilon$} (q2)
			  (q2) edge node[right]{$\varepsilon, \varepsilon, \big \langle B, B, -1 \big\rangle $} (q3)
			  (q3) edge node[below right]{$\varepsilon, \varepsilon, \big \langle B, B, 1 \big\rangle $} (q5)
			  (q3) edge[loop above] node[above]{$\varepsilon, \varepsilon, \big \langle b, B, -1 \big\rangle $} node[above=3mm]{$\varepsilon, \varepsilon, \big \langle a, B, -1 \big\rangle $} (q3)
			  (q5) edge node[left]{$\varepsilon, \varepsilon, \varepsilon $} (q6)
			  (q5) edge node[below]{$\varepsilon, \varepsilon, \varepsilon $} (q8)
			  (q7) edge node[right]{$\varepsilon, \varepsilon, \varepsilon $} (q8)
			  (q7) edge[bend right] node[above]{$\varepsilon, \varepsilon, \varepsilon $} (q6)
			  (q6) edge[bend right] node[below]{$ \big \langle b, B, 1 \big\rangle , \varepsilon, \big \langle B, b, 1 \big\rangle $}  (q7)
    			  (q8) edge node[right]{$\varepsilon, \varepsilon, \varepsilon $} (q9)
			  (q9) edge node[above]{$\varepsilon, \varepsilon, \varepsilon $} (q10)
			  (q10) edge node[above]{$\varepsilon, \varepsilon, \varepsilon $} (q4)
			  (q4) edge node[below left]{$\varepsilon, \varepsilon, \varepsilon $} (q11)
			  (q11) edge node[above right]{$\varepsilon,  \big \langle B, B, -1 \big\rangle, \varepsilon $} (q12)
			  (q12) edge node[below left]{$\varepsilon, \big \langle B, B, 1 \big\rangle, \varepsilon $} (q14)
			  (q12) edge[loop right] node[below right =-0.5mm and 0mm]{$\varepsilon,\big \langle b, B, -1 \big\rangle, \varepsilon$} node[above right=-0.5mm and 0mm]{$\varepsilon, \big \langle a, B, -1 \big\rangle, \varepsilon $} (q12)
			  (q14) edge node[above left]{$\varepsilon, \varepsilon, \varepsilon $} (q15)
			  (q14) edge node[right]{$\varepsilon, \varepsilon, \varepsilon $} (q17)
			  (q16) edge node[below left]{$\varepsilon, \varepsilon, \varepsilon $} (q17)
			  (q16) edge[bend right] node[right]{$\varepsilon, \varepsilon, \varepsilon $} (q15)
			  (q15) edge[bend right] node[left]{$ \big \langle a, B, 1 \big\rangle, \big \langle B, a, 1 \big\rangle, \varepsilon$}  (q16)
    			  (q17) edge node[right]{$\varepsilon, \varepsilon, \varepsilon $} (q28)
			  (q28) edge node[below]{$\varepsilon, \varepsilon, \varepsilon $} (q29)
		          (q29) edge node[left]{$\varepsilon, \varepsilon, \varepsilon $} (q18)
			  (q18) edge node[above]{$\varepsilon, \varepsilon, \varepsilon $} (q19)
			  (q19) edge[bend right] node[above]{$\big \langle b, B, 1 \big\rangle, \varepsilon, \varepsilon $} (q20)
			  (q20) edge node[above right]{$\varepsilon, \varepsilon, \varepsilon $} (q21)
			  (q21) edge node[above left]{$\varepsilon, \varepsilon, \varepsilon $} (q22)
			  (q22) edge[bend left] node[below]{$\varepsilon,  \big \langle B, B, -1 \big\rangle, \varepsilon $} (q23)
			  (q23) edge node[left]{$\varepsilon,  \big \langle B, B, 1 \big\rangle, \varepsilon $} (q24)
			  (q24) edge[bend right] node[above]{$\varepsilon,  \big \langle B, B, 0 \big\rangle, \varepsilon $} (q25)
			  (q24) edge[loop above] node[above]{$\langle b, B, 1 \big\rangle, \big \langle b, b, 1 \big\rangle, \varepsilon$} node[above=3mm]{$\langle a, B, 1 \big\rangle, \big \langle a, a, 1 \big\rangle, \varepsilon$} (q24)
			  (q23) edge[loop left] node[below left =-0.5mm and 0mm]{$\varepsilon, \big \langle b, b, -1 \big\rangle, \varepsilon$} node[above left =-0.5mm and 0mm]{$\varepsilon, \big \langle a, a, -1 \big\rangle, \varepsilon$} (q23)
			  (q25) edge node[above right]{$\varepsilon, \varepsilon, \varepsilon $} (q26)
			  (q26) edge node[left]{$\varepsilon, \varepsilon, \varepsilon $} (q27)
			  (q27) edge node[left]{$\varepsilon, \varepsilon, \varepsilon $} (q1);
			  
		
	\end{tikzpicture}
	\caption{Přechodová funkce $TS(3)$ přijímajícího jazyk $L(y\{b^\ast\} \ x\{a^\ast\} \ b \ x)$}
	\label{fig:examplets}
\end{figure}


\section{Ukázka převodu regexu na memory automat}\label{ukazka:avd}
Nejprve sestrojme graf $\mathcal{H}(\alpha)$ podle definice (viz obrázek \ref{fig:avdappendix}). 

\begin{figure}[h]
\centering

\begin{tikzpicture}
	\tikzstyle{vertex}=[fill=gray!15, rounded corners, minimum height=1cm, minimum width=1cm]	

	\node[vertex] (con1) {$\cdot$};
	\node[vertex, below left=0.7cm and 2cm of con1] (defy) {$y\{\}$};
	\node[vertex, below=0.7cm of defy] (itb) {$\ast$};
	\node[vertex, below=0.7cm of itb] (b) {$b$};
	\node[vertex, below right=0.7cm and 2cm of con1] (con2) {$\cdot$};
	\node[vertex, below left=0.7cm and 0.5cm of con2] (defx) {$x\{\}$};
	\node[vertex, below=0.7cm of defx] (ita) {$\ast$};
	\node[vertex, below=0.7cm of ita] (a) {$a$};
	\node[vertex, below right=0.7cm and 0.5cm of con2] (con3) {$\cdot$};
	\node[vertex, below left=0.7cm and 0.25cm of con3] (b2) {$b$};
	\node[vertex, below right=0.7cm and 0.25cm of con3] (x) {$x$};

		\tikzstyle{dot} = [draw,shape=circle,fill=blue!30, inner sep=0pt, minimum size=4pt]
		\node[dot, left=-2mm of con1] (con1in) {};
		\node[dot, right=-2mm of con1] (con1out) {};
		\node[dot, below=-2mm of con1] (con1mid) {};
		\node[dot, left=-2mm of defy] (defyin) {};
		\node[dot, right=-2mm of defy] (defyout) {};	
		\node[dot, left=-2mm of b] (bin) {};
		\node[dot, right=-2mm of b] (bout) {};
		\node[dot, fill=red, left=-2mm of itb] (itbin) {};
		\node[dot, right=-2mm of itb] (itbout) {};
		\node[dot, left=-2mm of a] (ain) {};
		\node[dot, right=-2mm of a] (aout) {};
		\node[dot, fill=red, left=-2mm of ita] (itain) {};
		\node[dot, right=-2mm of ita] (itaout) {};
		\node[dot, left=-2mm of con2] (con2in) {};
		\node[dot, right=-2mm of con2] (con2out) {};
		\node[dot, below=-2mm of con2] (con2mid) {};	
		\node[dot, left=-2mm of x] (xin) {};
		\node[dot,  right=-2mm of x] (xout) {};
		\node[dot, left=-2mm of con3] (con3in) {};
		\node[dot, right=-2mm of con3] (con3out) {};
		\node[dot, below=-2mm of con3] (con3mid) {};	
		\node[dot, left=-2mm of b2] (b2in) {};
		\node[dot, right=-2mm of b2] (b2out) {};
		\node[dot, left=-2mm of defx] (defxin) {};
		\node[dot, right=-2mm of defx] (defxout) {};
	

		\draw 	(con1in) edge[bend right] (defyin)
				(defyout) edge[bend right] (con1mid)
				(defyin) edge[bend right] node[left]{$[\,_y$} node[below left=5mm and 0mm]{$avs(\beta_{in})=\varnothing$} (itbin)
				(itbout) edge[bend right] node[right]{$]\,_y$} (defyout)
				(itbin) edge[bend right=60] (itbout)
				(itbout) edge[bend right=60] (itbin)
				(itbin) edge[bend right] (bin)
				(bout) edge[bend right] (itbout)
				(bin) edge[bend right=60] node[below]{\texttt{b}} (bout)
				(con1mid) edge[bend right] (con2in)
				(con2in) edge[bend right] (defxin)
				(defxout) edge[bend right] (con2mid)
				(defxin) edge[bend right] node[left]{$[\,_x$} node[below left=5mm and 0mm]{$avs(\gamma_{in})=\{x\}$} (itain)
				(itaout) edge[bend right] node[right]{$]\,_x$} (defxout)
				(itain) edge[bend right=60] (itaout)
				(itaout) edge[bend right=60] (itain)
				(itain) edge[bend right] (ain)
				(aout) edge[bend right] (itaout)
				(ain) edge[bend right=60] node[below]{\texttt{a}} (aout)
				(con2mid) edge[bend right] (con3in)
				(con3in) edge[bend right] (b2in)
				(b2in) edge[bend right=60] node[below]{\texttt{b}} (b2out)
				(b2out) edge[bend right] (con3mid)
				(con3mid) edge[bend right] (xin)
				(xin) edge[bend right=60] node[below]{\texttt{x}} (xout)
				(xout) edge[bend right] (con3out)
				(con3out) edge[bend right] (con2out)
				(con2out) edge[bend right] (con1out);
				
				
\end{tikzpicture}
\caption{Graf $\mathcal{H}(y\{b^\ast\} \ x\{a^\ast\} \ b \ x)$}\label{fig:avdappendix}
\end{figure}

\begin{itemize}
\item{Algoritmus \texttt{simpleMemory}.
Zobrazení $num$ lze definovat například takto: $num(x) := 1; \ num(y) := 2$, což znamená, že první (resp. druhá) paměť automatu je vyhrazena pro proměnnou $x$ (resp. $y$). Přechodová funkce $\mu KA(2)$ $\mathcal{M} = (V(\mathcal{H}(\alpha)), \Sigma, \delta, \varphi_{in}, \{\varphi_{out}\})$ přijímajícího hodnotu daného regexu je zobrazena na obrázku \ref{fig:mem1}. }
\item{Algoritmus \texttt{avdMemory}. Parametr $avd$ je roven $$max\{|avd(\gamma_{in})|, |avd(\beta_{in})|\}=1.$$ Pro proměnnou $y$ automat nepoužije žádnou paměť (pro každý vrchol $v \in V(\mathcal{H}(\alpha))$ platí $v \ntriangleright_{call} y$). Při konstrukci memory automatu pro hrany ohodnocené $[\,_y$ a $]\,_y$ algoritmus přidá $\varepsilon$-přechody (podle pravidla \ref{rule3} na s. 43). Výsledný $\mu KA(1)$ $\mathcal{M} = (Q^\prime, \Sigma, \delta^\prime, (\varphi_{in}, \langle \bot \rangle), \{ (\varphi_{out}, \langle \bot \rangle)\})$ přijímá hodnotu regexu $\alpha$ ($\delta^\prime$ je znázorněna pomocí grafu přechodové funkce na obrázku \ref{fig:mem2}). $Q^\prime$ je množina stavů, kde každý stav obsahuje \emph{memory list}. }
\end{itemize}
\begin{figure}[h]
\centering

\begin{tikzpicture}
	\tikzstyle{vertex}=[fill=white, rounded corners, minimum height=1cm, minimum width=1cm]	

	\node[vertex] (con1) {};
	\node[vertex, below left=0.7cm and 2cm of con1] (defy) {};
	\node[vertex, below=0.7cm of defy] (itb) {};
	\node[vertex, below=0.7cm of itb] (b) {};
	\node[vertex, below right=0.7cm and 2cm of con1] (con2) {};
	\node[vertex, below left=0.7cm and 0.5cm of con2] (defx) {};
	\node[vertex, below=0.7cm of defx] (ita) {};
	\node[vertex, below=0.7cm of ita] (a) {};
	\node[vertex, below right=0.7cm and 0.5cm of con2] (con3) {};
	\node[vertex, below left=0.7cm and 0.25cm of con3] (b2) {};
	\node[vertex, below right=0.7cm and 0.25cm of con3] (x) {};

		\tikzstyle{dot} = [draw,shape=circle,fill=blue!30, inner sep=0pt, minimum size=4pt]
		\node[dot, initial, left=20mm of con1] (con1in) {};
		\node[dot, accepting, right=20mm of con1] (con1out) {};
		\node[dot, below=-2mm of con1] (con1mid) {};
		\node[dot, left=-2mm of defy] (defyin) {};
		\node[dot, right=-2mm of defy] (defyout) {};	
		\node[dot, left=-2mm of b] (bin) {};
		\node[dot, right=-2mm of b] (bout) {};
		\node[dot, left=-2mm of itb] (itbin) {};
		\node[dot, right=-2mm of itb] (itbout) {};
		\node[dot, left=-2mm of a] (ain) {};
		\node[dot, right=-2mm of a] (aout) {};
		\node[dot, left=-2mm of ita] (itain) {};
		\node[dot, right=-2mm of ita] (itaout) {};
		\node[dot, left=-2mm of con2] (con2in) {};
		\node[dot, right=-2mm of con2] (con2out) {};
		\node[dot, below=-2mm of con2] (con2mid) {};	
		\node[dot, left=-2mm of x] (xin) {};
		\node[dot, right=-2mm of x] (xout) {};
		\node[dot, left=-2mm of con3] (con3in) {};
		\node[dot, right=-2mm of con3] (con3out) {};
		\node[dot, below=-2mm of con3] (con3mid) {};	
		\node[dot, left=-2mm of b2] (b2in) {};
		\node[dot, right=-2mm of b2] (b2out) {};
		\node[dot, left=-2mm of defx] (defxin) {};
		\node[dot, right=-2mm of defx] (defxout) {};
	

		\draw 	(con1in) edge[bend right] node[left]{$\varepsilon$} (defyin)
				(defyout) edge[bend right] node[below]{$\varepsilon$} (con1mid)
				(itbout) edge[bend right] node[right]{$]\,_2$} (defyout)
				(defyin) edge[bend right] node[left]{$[\,_2$} (itbin)
				(itbin) edge[bend right=60] node[below]{$\varepsilon$} (itbout)
				(itbout) edge[bend right=60] node[above]{$\varepsilon$} (itbin)
				(itbin) edge[bend right] node[left]{$\varepsilon$} (bin)
				(bout) edge[bend right] node[right]{$\varepsilon$} (itbout)
				(bin) edge[bend right=60] node[below]{\texttt{b}} (bout)
				(con1mid) edge[bend right] node[below]{$\varepsilon$} (con2in)
				(con2in) edge[bend right] node[left]{$\varepsilon$} (defxin)
				(defxout) edge[bend right]node[right]{$\varepsilon$} (con2mid)
				(itaout) edge[bend right] node[right]{$]\,_1$} (defxout)
				(defxin) edge[bend right] node[left]{$[\,_1$} (itain)
				(itain) edge[bend right=60] node[below]{$\varepsilon$} (itaout)
				(itaout) edge[bend right=60] node[above]{$\varepsilon$} (itain)
				(itain) edge[bend right] node[left]{$\varepsilon$} (ain)
				(aout) edge[bend right] node[right]{$\varepsilon$} (itaout)
				(ain) edge[bend right=60] node[below]{\texttt{a}} (aout)
				(con2mid) edge[bend right] node[right]{$\varepsilon$} (con3in)
				(con3in) edge[bend right] node[right]{$\varepsilon$}(b2in)
				(b2in) edge[bend right=60] node[below]{\texttt{b}} (b2out)
				(b2out) edge[bend right] node[below right]{$\varepsilon$} (con3mid)
				(con3mid) edge[bend right] node[right]{$\varepsilon$} (xin)
				(xin) edge[bend right=60] node[below]{\texttt{1}} (xout)
				(xout) edge[bend right] node[right]{$\varepsilon$} (con3out)
				(con3out) edge[bend right]  node[right]{$\varepsilon$} (con2out)
				(con2out) edge[bend right]  node[right]{$\varepsilon$} (con1out);
				
				
\end{tikzpicture}
\caption{Přechodová funkce $\mu KA(2)$ přijímajícího $L(y\{b^\ast\} \ x\{a^\ast\} \ b \ x)$}\label{fig:mem1}
\end{figure}

\begin{figure}[h]
\centering
\begin{tikzpicture}
	\tikzstyle{vertex}=[fill=white, rounded corners, minimum height=1cm, minimum width=1cm]	

	\node[vertex] (con1) {};
	\node[vertex, below left=0.7cm and 2cm of con1] (defy) {};
	\node[vertex, below=0.7cm of defy] (itb) {};
	\node[vertex, below=0.7cm of itb] (b) {};
	\node[vertex, below right=0.7cm and 2cm of con1] (con2) {};
	\node[vertex, below left=0.7cm and 0.75cm of con2] (defx) {};
	\node[vertex, below=0.7cm of defx] (ita) {};
	\node[vertex, below=0.7cm of ita] (a) {};
	\node[vertex, below right=0.7cm and 0.75cm of con2] (con3) {};
	\node[vertex, below left=0.7cm and 0.25cm of con3] (b2) {};
	\node[vertex, below right=0.7cm and 0.25cm of con3] (x) {};

		\tikzstyle{dot} = [draw,shape=circle,fill=blue!5, inner sep=0pt, minimum size=15pt]
		\node[dot, initial, left=20mm of con1] (con1in) {$\bot$};
		\node[dot, accepting, right=20mm of con1] (con1out) {$\bot$};
		\node[dot, below=-2mm of con1] (con1mid) {$\bot$};
		\node[dot, left=-2mm of defy] (defyin) {$\bot$};
		\node[dot, right=-2mm of defy] (defyout) {$\bot$};	
		\node[dot, left=-2mm of b] (bin) {$\bot$};
		\node[dot, right=-2mm of b] (bout) {$\bot$};
		\node[dot, left=-2mm of itb] (itbin) {$\bot$};
		\node[dot, right=-2mm of itb] (itbout) {$\bot$};
		\node[dot, left=-2mm of a] (ain) {$x$};
		\node[dot, right=-2mm of a] (aout) {$x$};
		\node[dot, left=-2mm of ita] (itain) {$x$};
		\node[dot, right=-2mm of ita] (itaout) {$x$};
		\node[dot, left=-2mm of con2] (con2in) {$\bot$};
		\node[dot, right=-2mm of con2] (con2out) {$\bot$};
		\node[dot, below=-2mm of con2] (con2mid) {$x$};	
		\node[dot, left=-2mm of x] (xin) {$x$};
		\node[dot, right=-2mm of x] (xout) {$\bot$};
		\node[dot, left=-2mm of con3] (con3in) {$x$};
		\node[dot, right=-2mm of con3] (con3out) {$\bot$};
		\node[dot, below=-2mm of con3] (con3mid) {$x$};	
		\node[dot, left=-2mm of b2] (b2in) {$x$};
		\node[dot, right=-2mm of b2] (b2out) {$x$};
		\node[dot, left=-2mm of defx] (defxin) {$\bot$};
		\node[dot, right=-2mm of defx] (defxout) {$x$};
	

		\draw 	(con1in) edge[bend right] node[left]{$\varepsilon$} (defyin)
				(defyout) edge[bend right] node[below]{$\varepsilon$} (con1mid)
				(itbout) edge[bend right] node[right]{$\varepsilon$} (defyout)
				(defyin) edge[bend right] node[left]{$\varepsilon$} (itbin)
				(itbin) edge[bend right=60] node[below]{$\varepsilon$} (itbout)
				(itbout) edge[bend right=60] node[above]{$\varepsilon$} (itbin)
				(itbin) edge[bend right] node[left]{$\varepsilon$} (bin)
				(bout) edge[bend right] node[right]{$\varepsilon$} (itbout)
				(bin) edge[bend right=60] node[below]{\texttt{b}} (bout)
				(con1mid) edge[bend right] node[below]{$\varepsilon$} (con2in)
				(con2in) edge[bend right] node[left]{$\varepsilon$} (defxin)
				(defxout) edge[bend right]node[right]{$\varepsilon$} (con2mid)
				(itaout) edge[bend right] node[right]{$]\,_1$} (defxout)
				(defxin) edge[bend right] node[left]{$[\,_1$} (itain)
				(itain) edge[bend right=60] node[below]{$\varepsilon$} (itaout)
				(itaout) edge[bend right=60] node[above]{$\varepsilon$} (itain)
				(itain) edge[bend right] node[left]{$\varepsilon$} (ain)
				(aout) edge[bend right] node[right]{$\varepsilon$} (itaout)
				(ain) edge[bend right=60] node[below]{\texttt{a}} (aout)
				(con2mid) edge[bend right] node[right]{$\varepsilon$} (con3in)
				(con3in) edge[bend right] node[right]{$\varepsilon$}(b2in)
				(b2in) edge[bend right=60] node[below]{\texttt{b}} (b2out)
				(b2out) edge[bend right] node[left]{$\varepsilon$} (con3mid)
				(con3mid) edge[bend right] node[right]{$\varepsilon$} (xin)
				(xin) edge[bend right=60] node[below]{\texttt{1}} (xout)
				(xout) edge[bend right] node[right]{$\varepsilon$} (con3out)
				(con3out) edge[bend right]  node[right]{$\varepsilon$} (con2out)
				(con2out) edge[bend right]  node[right]{$\varepsilon$} (con1out);
				
				
\end{tikzpicture}
\caption{Přechodová funkce $\mu KA(1)$ přijímajícího $L(y\{b^\ast\} \ x\{a^\ast\} \ b \ x)$}\label{fig:mem2}
\end{figure}

\chapter{Seznam použitých zkratek}
% \printglossaries
\begin{description}
	\item[AST] Abstract Syntax Tree
	\item[DFS] Algoritmus \emph{Depth-first search}
	\item[LOTS] Lineárně omezený Turingův stroj
	\item[$\mu$KA] Memory automat
	\item[NKA] Nedeterministický konečný automat
	\item[TS] Turingův stroj
	\item[PCRE] Perl Compatible Regular Expressions
	\item[POSIX BRE] POSIX Basic Regular Expressions
	\item[POSIX ERE] POSIX Extended Regular Expressions
\end{description}


% % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% % Tuto kapitolu z~výsledné práce ODSTRAŇTE.
% % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% 
% \chapter{Návod k~použití této šablony}
% 
% Tento dokument slouží jako základ pro napsání závěrečné práce na Fakultě informačních technologií ČVUT v~Praze.
% 
% \section{Výběr základu}
% 
% Vyberte si šablonu podle druhu práce (bakalářská, diplomová), jazyka (čeština, angličtina) a kódování (ASCII, \mbox{UTF-8}, \mbox{ISO-8859-2} neboli latin2 a nebo \mbox{Windows-1250}). 
% 
% V~české variantě naleznete šablony v~souborech pojmenovaných ve formátu práce\_kódování.tex. Typ může být:
% \begin{description}
% 	\item[BP] bakalářská práce,
% 	\item[DP] diplomová (magisterská) práce.
% \end{description}
% Kódování, ve kterém chcete psát, může být:
% \begin{description}
% 	\item[UTF-8] kódování Unicode,
% 	\item[ISO-8859-2] latin2,
% 	\item[Windows-1250] znaková sada 1250 Windows.
% \end{description}
% V~případě nejistoty ohledně kódování doporučujeme následující postup:
% \begin{enumerate}
% 	\item Otevřete šablony pro kódování UTF-8 v~editoru prostého textu, který chcete pro psaní práce použít -- pokud můžete texty s~diakritikou normálně přečíst, použijte tuto šablonu.
% 	\item V~opačném případě postupujte dále podle toho, jaký operační systém používáte:
% 	\begin{itemize}
% 		\item v~případě Windows použijte šablonu pro kódování \mbox{Windows-1250},
% 		\item jinak zkuste použít šablonu pro kódování \mbox{ISO-8859-2}.
% 	\end{itemize}
% \end{enumerate}
% 
% 
% V~anglické variantě jsou šablony pojmenované podle typu práce, možnosti jsou:
% \begin{description}
% 	\item[bachelors] bakalářská práce,
% 	\item[masters] diplomová (magisterská) práce.
% \end{description}
% 
% \section{Použití šablony}
% 
% Šablona je určena pro zpracování systémem \LaTeXe{}. Text je možné psát v~textovém editoru jako prostý text, lze však také využít specializovaný editor pro \LaTeX{}, např. Kile.
% 
% Pro získání tisknutelného výstupu z~takto vytvořeného souboru použijte příkaz \verb|pdflatex|, kterému předáte cestu k~souboru jako parametr. Vhodný editor pro \LaTeX{} toto udělá za Vás. \verb|pdfcslatex| ani \verb|cslatex| \emph{nebudou} s~těmito šablonami fungovat.
% 
% Více informací o~použití systému \LaTeX{} najdete např. v~\cite{wikilatex}.
% 
% \subsection{Typografie}
% 
% Při psaní dodržujte typografické konvence zvoleného jazyka. České \uv{uvozovky} zapisujte použitím příkazu \verb|\uv|, kterému v~parametru předáte text, jenž má být v~uvozovkách. Anglické otevírací uvozovky se v~\LaTeX{}u zadávají jako dva zpětné apostrofy, uzavírací uvozovky jako dva apostrofy. Často chybně uváděný symbol "{} (palce) nemá s~uvozovkami nic společného.
% 
% Dále je třeba zabránit zalomení řádky mezi některými slovy, v~češtině např. za jednopísmennými předložkami a spojkami (vyjma \uv{a}). To docílíte vložením pružné nezalomitelné mezery -- znakem \texttt{\textasciitilde}. V~tomto případě to není třeba dělat ručně, lze použít program \verb|vlna|.
% 
% Více o~typografii viz \cite{kobltypo}.
% 
% \subsection{Obrázky}
% 
% Pro umožnění vkládání obrázků je vhodné použít balíček \verb|graphicx|, samotné vložení se provede příkazem \verb|\includegraphics|. Takto je možné vkládat obrázky ve formátu PDF, PNG a JPEG jestliže používáte pdf\LaTeX{} nebo ve formátu EPS jestliže používáte \LaTeX{}. Doporučujeme preferovat vektorové obrázky před rastrovými (vyjma fotografií).
% 
% \subsubsection{Získání vhodného formátu}
% 
% Pro získání vektorových formátů PDF nebo EPS z~jiných lze použít některý z~vektorových grafických editorů. Pro převod rastrového obrázku na vektorový lze použít rasterizaci, kterou mnohé editory zvládají (např. Inkscape). Pro konverze lze použít též nástroje pro dávkové zpracování běžně dodávané s~\LaTeX{}em, např. \verb|epstopdf|.
% 
% \subsubsection{Plovoucí prostředí}
% 
% Příkazem \verb|\includegraphics| lze obrázky vkládat přímo, doporučujeme však použít plovoucí prostředí, konkrétně \verb|figure|. Například obrázek \ref{fig:float} byl vložen tímto způsobem. Vůbec přitom nevadí, když je obrázek umístěn jinde, než bylo původně zamýšleno -- je tomu tak hlavně kvůli dodržení typografických konvencí. Namísto vynucování konkrétní pozice obrázku doporučujeme používat azování z~textu (dvojice příkazů \verb|\label| a \verb|\ref|).
% 
% \begin{figure}\centering
% 	\includegraphics[width=0.5\textwidth, angle=30]{cvut-logo-bw}
% 	\caption[Příklad obrázku]{Ukázkový obrázek v~plovoucím prostředí}\label{fig:float}
% \end{figure}
% 
% \subsubsection{Verze obrázků}
% 
% % Gnuplot BW i barevně
% Může se hodit mít více verzí stejného obrázku, např. pro barevný či černobílý tisk a nebo pro prezentaci. S~pomocí některých nástrojů na generování grafiky je to snadné.
% 
% Máte-li například graf vytvořený v~programu Gnuplot, můžete jeho černobílou variantu (viz obr. \ref{fig:gnuplot-bw}) vytvořit parametrem \verb|monochrome dashed| příkazu \verb|set term|. Barevnou variantu (viz obr. \ref{fig:gnuplot-col}) vhodnou na prezentace lze vytvořit parametrem \verb|colour solid|.
% 
% \begin{figure}\centering
% 	\includegraphics{gnuplot-bw}
% 	\caption{Černobílá varianta obrázku generovaného programem Gnuplot}\label{fig:gnuplot-bw}
% \end{figure}
% 
% \begin{figure}\centering
% 	\includegraphics{gnuplot-col}
% 	\caption{Barevná varianta obrázku generovaného programem Gnuplot}\label{fig:gnuplot-col}
% \end{figure}
% 
% 
% \subsection{Tabulky}
% 
% Tabulky lze zadávat různě, např. v~prostředí \verb|tabular|, avšak pro jejich vkládání platí to samé, co pro obrázky -- použijte plovoucí prostředí, v~tomto případě \verb|table|. Například tabulka \ref{tab:matematika} byla vložena tímto způsobem.
% 
% \begin{table}\centering
% 	\caption[Příklad tabulky]{Zadávání matematiky}\label{tab:matematika}
% 	\begin{tabular}{|l|l|c|c|}\hline
% 		Typ		& Prostředí		& \LaTeX{}ovská zkratka	& \TeX{}ovská zkratka	\tabularnewline \hline \hline
% 		Text		& \verb|math|		& \verb|\(...\)|	& \verb|$...$F|		\tabularnewline \hline
% 		Displayed	& \verb|displaymath|	& \verb|\[...\]|	& \verb|$$...$$|	\tabularnewline \hline
% 	\end{tabular}
% \end{table}
% 
% % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\chapter{Obsah přiloženého CD}

%upravte podle skutecnosti

\begin{figure}
	\dirtree{%
		.1 BP\_Zaporozhchenko\_Oleksandr\_2020.pdf\DTcomment{text práce ve formátu PDF}.
		.1 README.md\DTcomment{stručný popis obsahu CD}.
		.1 src.
		.2 Doxyfile\DTcomment{konfigurační soubor nástroje Doxygen}.
		.2 impl\DTcomment{zdrojové kódy implementace}.
		.2 Makefile.
		.2 test.sh\DTcomment{skript určený pro testování správnosti implementací}.
		.2 testGrep.sh\DTcomment{skript určený pro spuštění testů v~programu grep}.
		.2 testPerl.sh\DTcomment{skript určený pro spuštění testů v~jazyce Perl}.
		.2 testTime.sh\DTcomment{skript určený pro měření času běhu}.
		.2 tests\DTcomment{datové sady použité pro testování}.
		.2 thesis\DTcomment{zdrojová forma práce ve formátu \LaTeX{}}.
	}
\end{figure}

\end{document}
